<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Online Video Classroom</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles for the canvas and video elements */
        body {
            font-family: "Inter", sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .modern-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .video-container {
            position: relative;
            width: 100%;
            padding-top: 56.25%; /* 16:9 Aspect Ratio */
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 1rem;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .video-container.teacher-video {
            width: 80%;
            margin: 0 auto;
            padding-top: 45%; /* Reduced height for teacher video */
            max-width: 400px; /* Limit maximum width */
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
        }
        
        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover; /* Ensures video fills the container */
            border-radius: 1rem;
        }
        
        #whiteboardCanvas {
            border: 2px solid #e2e8f0;
            background-color: #fff;
            cursor: crosshair;
            border-radius: 1rem;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
        }
        
        /* Style to indicate disabled drawing on canvas */
        #whiteboardCanvas.disabled {
            cursor: not-allowed;
            background-color: #f8f9fa;
            opacity: 0.7;
            border-color: #dee2e6;
        }
        
        /* Modal styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 100;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.5);
            backdrop-filter: blur(5px);
            justify-content: center;
            align-items: center;
        }
        
        .modal-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            margin: auto;
            padding: 2rem;
            border: 1px solid rgba(255, 255, 255, 0.3);
            width: 90%;
            max-width: 600px;
            border-radius: 1.5rem;
            box-shadow: 0 25px 50px rgba(0,0,0,0.15);
        }
        
        .close-button {
            color: #6b7280;
            float: right;
            font-size: 1.5rem;
            font-weight: bold;
            transition: color 0.3s ease;
        }
        
        .close-button:hover,
        .close-button:focus {
            color: #374151;
            text-decoration: none;
            cursor: pointer;
        }

        /* Styles for the dynamic textarea */
        .whiteboard-text-input {
            position: absolute;
            background: rgba(255, 255, 255, 0.95);
            border: 2px dashed #6366f1;
            padding: 0.5rem;
            outline: none;
            resize: none;
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            z-index: 50;
            border-radius: 0.5rem;
            font-size: 16px;
            font-family: 'Inter', sans-serif;
            transition: all 0.3s ease;
        }
        
        .whiteboard-text-input:focus {
            border: 2px solid #4f46e5;
            box-shadow: 0 6px 20px rgba(79, 70, 229, 0.2);
        }

        /* Style for active tool button */
        .tool-active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%) !important;
            color: white !important;
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4) !important;
        }
        
        /* Modern button styles */
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }
        
        .btn-secondary {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }
        
        .btn-secondary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
        }
        
        .btn-danger {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }
        
        .btn-warning {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        
        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }
        
        .btn-tool {
            background: rgba(255, 255, 255, 0.9);
            color: #374151;
            border: 1px solid rgba(209, 213, 219, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 0.75rem;
            font-weight: 500;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .btn-tool:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }
        
        /* Input styles */
        .modern-input {
            background: rgba(255, 255, 255, 0.9);
            border: 1px solid rgba(209, 213, 219, 0.5);
            padding: 0.75rem 1rem;
            border-radius: 0.75rem;
            font-size: 1rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .modern-input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: rgba(255, 255, 255, 1);
        }
        
        /* Status message styles */
        .status-info {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            border: 1px solid rgba(59, 130, 246, 0.2);
            color: #1e40af;
        }
        
        .status-success {
            background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%);
            border: 1px solid rgba(34, 197, 94, 0.2);
            color: #166534;
        }
        
        .status-error {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            border: 1px solid rgba(239, 68, 68, 0.2);
            color: #991b1b;
        }
        
        /* Animation classes */
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .slide-up {
            animation: slideUp 0.3s ease-out;
        }
        
        @keyframes slideUp {
            from { transform: translateY(100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }
        
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: rgba(102, 126, 234, 0.5);
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(102, 126, 234, 0.7);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4">
    <div class="container mx-auto p-6 modern-card rounded-2xl max-w-7xl w-full fade-in">
        <!-- Header Section -->
        <div class="text-center mb-8">
            <h1 class="text-5xl font-bold bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent mb-2">
                🎓 Aisha Classroom
        </h1>
            <p class="text-gray-600 text-lg font-medium">Modern Online Learning Experience</p>
        </div>
        
        <!-- Subject Banner -->
        <div id="subjectBanner" class="text-center mb-6">
            <span id="subjectText" class="text-xl font-semibold text-purple-700 bg-purple-100 px-4 py-2 rounded-full"></span>
            <span id="subjectEditContainer" class="hidden">
                <input id="subjectInput" type="text" placeholder="Enter subject" class="modern-input ml-2">
                <button id="setSubjectBtn" class="btn-primary ml-2">Set</button>
            </span>
        </div>
        
        <!-- Room and User Controls -->
        <div class="flex flex-col md:flex-row items-center justify-center space-y-4 md:space-y-0 md:space-x-4 mb-8">
            <input type="text" id="usernameInput" placeholder="Your Name"
                   class="modern-input w-full md:w-auto">
            <input type="text" id="roomInput" placeholder="Room ID (e.g., class101)"
                   class="modern-input w-full md:w-auto">
            <button id="createRoomBtn" class="btn-primary w-full md:w-auto">
                <span class="font-semibold">➕ Create Class</span>
            </button>
            <button id="joinRoomBtn" class="btn-secondary w-full md:w-auto">
                <span class="font-semibold">➡️ Join Class</span>
            </button>
        </div>

        <!-- Teacher Info / Class Roster Section -->
        <div id="teacherInfo" class="hidden text-center text-lg text-gray-700 mb-4 p-4 bg-gradient-to-r from-blue-50 to-indigo-50 rounded-xl shadow-sm border border-blue-200">
            <span class="font-semibold text-blue-800">👨‍🏫 Teacher:</span> <span id="teacherName" class="font-semibold text-blue-800"></span>
        </div>

        <div id="classRosterSection" class="hidden mb-8 p-6 bg-gradient-to-br from-gray-50 to-gray-100 rounded-xl shadow-inner border border-gray-200">
            <h3 class="text-2xl font-semibold text-gray-700 mb-4 text-center">👥 Class Roster</h3>
            <ul id="classRosterList" class="space-y-3 max-h-60 overflow-y-auto">
                <!-- Roster items will be dynamically added here -->
            </ul>
            <p id="emptyRosterMessage" class="text-gray-500 text-sm text-center mt-4">No other participants yet.</p>
        </div>

        <!-- Classroom Area: Video and Whiteboard -->
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-8 mb-8">
            <!-- Video Streams -->
            <div class="flex flex-col space-y-6 lg:col-span-1">
                <h2 id="videoStreamsHeader" class="text-2xl font-semibold text-gray-700 text-center">📹 Video Streams</h2>
                
                <!-- Screen Sharing Status -->
                <div id="screenShareStatus" class="hidden bg-gradient-to-r from-green-100 to-emerald-100 border border-green-200 rounded-xl p-4 text-center shadow-sm">
                    <div class="flex items-center justify-center gap-2 text-green-700">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
                        </svg>
                        <span class="font-medium">Screen Sharing Active</span>
                    </div>
                    <p class="text-sm text-green-600 mt-1" id="screenShareInfo">Shared by: <span id="screenShareOwner"></span></p>
                </div>
                
                <!-- Video Source Toggle (for students) -->
                <div id="videoSourceToggle" class="hidden bg-gradient-to-r from-purple-100 to-indigo-100 border border-purple-200 rounded-xl p-4 text-center shadow-sm">
                    <div class="flex items-center justify-center gap-2 text-purple-700 mb-3">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 10l4.553-2.276A1 1 0 0121 8.618v6.764a1 1 0 01-1.447.894L15 14M5 18h8a2 2 0 002-2V8a2 2 0 00-2-2H5a2 2 0 00-2 2v8a2 2 0 002 2z"></path>
                        </svg>
                        <span class="font-medium">Now Showing: <span id="currentVideoSource">Teacher</span></span>
                    </div>
                    <div class="flex gap-2 justify-center">
                        <button id="showTeacherBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded-lg text-sm transition-colors duration-200">
                            👨‍🏫 Teacher
                        </button>
                        <button id="showScreenShareBtn" class="bg-purple-600 hover:bg-purple-700 text-white px-3 py-1 rounded-lg text-sm transition-colors duration-200">
                            🖥️ Screen Share
                        </button>
                    </div>
                </div>
                
                <!-- Screen Sharing Permission Request -->
                <div id="screenSharePermissionRequest" class="hidden bg-gradient-to-r from-blue-100 to-indigo-100 border border-blue-200 rounded-xl p-4 text-center shadow-sm">
                    <div class="flex items-center justify-center gap-2 text-blue-700 mb-3">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
                        </svg>
                        <span class="font-medium">Request Screen Sharing Permission</span>
                    </div>
                    <button id="requestScreenShareBtn" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg transition-colors duration-200">
                        Request Permission
                    </button>
                </div>
                <div class="video-container teacher-video">
                    <video id="localVideo" autoplay muted playsinline class="rounded-xl shadow-lg"></video>
                    <div id="localVideoLabel" class="absolute bottom-3 left-3 bg-black bg-opacity-60 text-white text-sm px-3 py-1 rounded-full backdrop-blur-sm">
                        You
                    </div>
                    
                    <!-- Screen Sharing Controls -->
                    <div class="absolute top-3 right-3 flex flex-col gap-2">
                        <button id="screenShareBtn" class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded-lg shadow-lg transition-colors duration-200 flex items-center gap-2" title="Share Screen">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.75 17L9 20l-1 1h8l-1-1-.75-3M3 13h18M5 17h14a2 2 0 002-2V5a2 2 0 00-2-2H5a2 2 0 00-2 2v10a2 2 0 002 2z"></path>
                            </svg>
                            Share
                        </button>
                        <button id="stopScreenShareBtn" class="bg-red-600 hover:bg-red-700 text-white p-2 rounded-lg shadow-lg transition-colors duration-200 flex items-center gap-2 hidden" title="Stop Sharing">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                            Stop
                        </button>
                    </div>
                </div>
                <!-- Remote videos will be dynamically added here -->
                <div id="remoteVideos" class="grid grid-cols-1 gap-4">
                    <!-- Placeholder for remote videos -->
                    <div class="video-container bg-gradient-to-br from-gray-200 to-gray-300 flex items-center justify-center text-gray-500 text-lg rounded-xl shadow-lg">
                        <div class="text-center">
                            <div class="text-4xl mb-2">👥</div>
                            <div>Waiting for participants...</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Whiteboard -->
            <div class="flex flex-col space-y-6 lg:col-span-2">
                <h2 class="text-2xl font-semibold text-gray-700 text-center">✏️ Interactive Whiteboard</h2>
                
                <!-- Typing Indicator -->
                <div id="typingIndicator" class="hidden text-center mb-4 p-3 bg-gradient-to-r from-blue-100 to-indigo-100 text-blue-700 rounded-xl shadow-sm border border-blue-200">
                    <span class="text-sm">👨‍🏫 <span id="typingTeacherName"></span> is typing...</span>
                </div>
                
                <div id="whiteboardContainer" class="relative w-full h-[600px] border-2 border-gray-300 rounded-xl shadow-xl bg-white">
                    <canvas id="whiteboardCanvas" class="w-full h-full rounded-xl"></canvas>
                </div>
                
                <!-- Toolbar -->
                <div class="bg-gradient-to-r from-gray-50 to-gray-100 rounded-xl p-4 shadow-inner border border-gray-200">
                    <div class="flex flex-wrap justify-center gap-3">
                    <!-- Drawing Tools -->
                        <button id="drawToolBtn" class="btn-tool tool-active">
                        <span class="font-semibold">✏️ Draw</span>
                    </button>
                        <button id="lineToolBtn" class="btn-tool">
                        <span class="font-semibold">— Line</span>
                    </button>
                        <button id="rectToolBtn" class="btn-tool">
                            <span class="font-semibold">☐ Rectangle</span>
                    </button>
                        <button id="ellipseToolBtn" class="btn-tool">
                        <span class="font-semibold">◯ Ellipse</span>
                    </button>
                        <button id="triangleToolBtn" class="btn-tool">
                        <span class="font-semibold">△ Triangle</span>
                    </button>
                        <button id="graphToolBtn" class="btn-tool">
                        <span class="font-semibold">📊 Graph</span>
                    </button>
                        <button id="fileSharingToolBtn" class="btn-tool">
                            <span class="font-semibold">📁 Files</span>
                        </button>
                        <button id="eraserToolBtn" class="btn-tool">
                        <span class="font-semibold">🧽 Eraser</span>
                    </button>

                    <input type="color" id="colorPicker" value="#000000"
                               class="w-12 h-10 border border-gray-300 rounded-lg cursor-pointer shadow-sm">
                        
                        <button id="clearWhiteboardBtn" class="btn-danger">
                        <span class="font-semibold">🗑️ Clear</span>
                    </button>

                        <button id="undoBtn" class="btn-warning">
                        <span class="font-semibold">↩️ Undo</span>
                    </button>
                        <button id="redoBtn" class="btn-warning">
                        <span class="font-semibold">↪️ Redo</span>
                    </button>

                        <!-- Text Tools -->
                        <button id="textToolBtn" class="btn-tool">
                        <span class="font-semibold">🅰️ Text</span>
                    </button>
                        <select id="fontSizeSelect" class="modern-input text-sm">
                        <option value="16px">16px</option>
                        <option value="20px" selected>20px</option>
                        <option value="24px">24px</option>
                        <option value="32px">32px</option>
                        <option value="48px">48px</option>
                    </select>
                        <select id="fontFamilySelect" class="modern-input text-sm">
                        <option value="Inter, sans-serif" selected>Inter</option>
                        <option value="Arial, sans-serif">Arial</option>
                        <option value="Verdana, sans-serif">Verdana</option>
                        <option value="Times New Roman, serif">Times New Roman</option>
                        <option value="Courier New, monospace">Courier New</option>
                    </select>
                        <button id="boldBtn" class="btn-tool font-bold">B</button>
                        <button id="italicBtn" class="btn-tool italic">I</button>
                        <button id="underlineBtn" class="btn-tool underline">U</button>

                        <!-- Media Controls -->
                        <button id="toggleMicBtn" class="btn-primary">
                        <span class="font-semibold">🎤 Toggle Mic</span>
                    </button>
                        <button id="toggleCamBtn" class="btn-primary">
                        <span class="font-semibold">📹 Toggle Cam</span>
                    </button>
                        
                    <!-- Student's Request Whiteboard Access Button -->
                        <button id="requestWhiteboardAccessBtn" class="hidden btn-warning">
                        <span class="font-semibold">✋ Request Whiteboard</span>
                    </button>
                        
                    <!-- Teacher's Manage Whiteboard Access Button -->
                        <button id="manageWhiteboardAccessBtn" class="hidden btn-primary">
                            <span class="font-semibold">⚙️ Manage Access</span>
                    </button>
                        
                    <!-- Teacher Quiz Button -->
                        <button id="createQuizBtn" class="hidden btn-primary">
                            <span class="font-semibold">📝 Create Quiz</span>
                        </button>
                        
                    <!-- Student Quiz Button -->
                        <button id="takeQuizBtn" class="hidden btn-secondary">
                            <span class="font-semibold">✏️ Take Quiz</span>
                        </button>
                    </div>
                </div>
                
                <!-- File Sharing Interface -->
                <div id="fileSharingInterface" class="hidden p-6 bg-gradient-to-br from-blue-50 to-indigo-50 rounded-xl shadow-inner border border-blue-200">
                    <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">📁 File Sharing</h3>
                    
                    <!-- File Upload Area -->
                    <div class="mb-6">
                        <div id="fileUploadArea" class="border-2 border-dashed border-blue-300 rounded-lg p-6 text-center hover:border-blue-400 transition-colors cursor-pointer">
                            <div class="text-4xl mb-2">📤</div>
                            <p class="text-gray-600 mb-2">Drag and drop files here or click to browse</p>
                            <p class="text-sm text-gray-500">Supports: Images, PDFs, Documents, and more</p>
                            <input type="file" id="fileInput" class="hidden" multiple>
                        </div>
                        <div id="uploadProgress" class="hidden mt-4">
                            <div class="bg-gray-200 rounded-full h-2">
                                <div id="progressBar" class="bg-blue-500 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                            <p id="uploadStatus" class="text-sm text-gray-600 mt-2">Uploading...</p>
                        </div>
                    </div>
                    
                    <!-- Shared Files List -->
                    <div>
                        <h4 class="text-lg font-semibold text-gray-700 mb-3">📋 Shared Files</h4>
                        <div id="sharedFilesList" class="space-y-3 max-h-60 overflow-y-auto">
                            <p id="noFilesMessage" class="text-gray-500 text-center py-4">No files shared yet.</p>
                        </div>
                    </div>
                </div>
                
                <!-- Graph Plotting Interface -->
                <div id="graphInterface" class="hidden p-6 bg-gradient-to-br from-green-50 to-emerald-50 rounded-xl shadow-inner border border-green-200">
                    <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">📊 Graph Plotting</h3>
                    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                        <!-- Function Input -->
                        <div class="space-y-3">
                            <label class="block text-sm font-medium text-gray-700">Function (e.g., x^2, sin(x), 2*x+1)</label>
                            <input type="text" id="functionInput" placeholder="Enter mathematical function" 
                                   class="modern-input w-full">
                            <div class="flex space-x-3">
                                <button id="plotFunctionBtn" class="btn-secondary">
                                    📈 Plot Function
                                </button>
                                <button id="clearGraphBtn" class="btn-danger">
                                    🗑️ Clear Graph
                                </button>
                            </div>
                        </div>
                        
                        <!-- Graph Settings -->
                        <div class="space-y-3">
                            <label class="block text-sm font-medium text-gray-700">Graph Settings</label>
                            <div class="grid grid-cols-2 gap-3">
                                <div>
                                    <label class="block text-xs text-gray-600">X Range</label>
                                    <input type="number" id="xMin" value="-10" class="modern-input w-full text-sm">
                                    <input type="number" id="xMax" value="10" class="modern-input w-full text-sm">
                                </div>
                                <div>
                                    <label class="block text-xs text-gray-600">Y Range</label>
                                    <input type="number" id="yMin" value="-10" class="modern-input w-full text-sm">
                                    <input type="number" id="yMax" value="10" class="modern-input w-full text-sm">
                                </div>
                            </div>
                            <div class="flex space-x-3">
                                <button id="showGridBtn" class="btn-primary text-sm">
                                    📐 Show Grid
                                </button>
                                <button id="autoScaleBtn" class="btn-primary text-sm">
                                    🔍 Auto Scale
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Quick Functions -->
                    <div class="mt-6">
                        <label class="block text-sm font-medium text-gray-700 mb-3">Quick Functions</label>
                        <div class="flex flex-wrap gap-2">
                            <button class="quick-function-btn bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm hover:bg-blue-200 transition-colors border border-blue-200" data-function="x">y = x</button>
                            <button class="quick-function-btn bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm hover:bg-blue-200 transition-colors border border-blue-200" data-function="x^2">y = x²</button>
                            <button class="quick-function-btn bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm hover:bg-blue-200 transition-colors border border-blue-200" data-function="x^3">y = x³</button>
                            <button class="quick-function-btn bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm hover:bg-blue-200 transition-colors border border-blue-200" data-function="sin(x)">y = sin(x)</button>
                            <button class="quick-function-btn bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm hover:bg-blue-200 transition-colors border border-blue-200" data-function="cos(x)">y = cos(x)</button>
                            <button class="quick-function-btn bg-blue-100 text-blue-800 px-4 py-2 rounded-lg text-sm hover:bg-blue-200 transition-colors border border-blue-200" data-function="1/x">y = 1/x</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Messages/Status -->
        <div id="statusMessage" class="text-center text-lg text-gray-600 mt-6 p-4 status-info rounded-xl shadow-sm">
            Enter a username and room ID to create or join a class.
        </div>

        <!-- Recording Controls (Teacher Only) -->
        <div id="recordingControls" class="hidden p-6 bg-gradient-to-br from-red-50 to-pink-50 rounded-xl shadow-inner border border-red-200 mt-4">
            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">🎥 Recording Controls</h3>
            <div class="flex flex-col space-y-3">
                <div class="flex space-x-2">
                    <button id="startRecordingBtn" class="btn-primary flex-1">
                        <span class="font-semibold">🔴 Start Recording</span>
                    </button>
                    <button id="stopRecordingBtn" class="btn-danger flex-1 hidden">
                        <span class="font-semibold">⏹️ Stop Recording</span>
                    </button>
                </div>
                <div id="recordingStatus" class="text-sm text-gray-600 text-center">
                    <span id="recordingIndicator" class="hidden inline-block w-3 h-3 bg-red-500 rounded-full animate-pulse mr-2"></span>
                    <span id="recordingStatusText">Ready to record</span>
                </div>
                <div id="recordingOptions" class="grid grid-cols-2 gap-2 text-sm">
                    <label class="flex items-center space-x-2">
                        <input type="checkbox" id="recordVideo" checked class="rounded">
                        <span>Video (Picture-in-Picture)</span>
                    </label>
                    <label class="flex items-center space-x-2">
                        <input type="checkbox" id="recordAudio" checked class="rounded">
                        <span>Audio</span>
                    </label>
                    <label class="flex items-center space-x-2">
                        <input type="checkbox" id="recordWhiteboard" checked class="rounded">
                        <span>Whiteboard (Background)</span>
                    </label>
                    <label class="flex items-center space-x-2">
                        <input type="checkbox" id="recordScreen" class="rounded">
                        <span>Screen Share (When Active)</span>
                    </label>
                </div>
                <div class="text-xs text-gray-600 mt-2 text-center">
                    💡 Recording will combine all selected sources into one video
                </div>
                <button id="debugRecordingBtn" class="btn-secondary text-xs mt-2 w-full">
                    🔍 Debug Recording Setup
                </button>
            </div>
        </div>

        <!-- Recording Playback Interface -->
        <div id="playbackInterface" class="hidden p-6 bg-gradient-to-br from-blue-50 to-cyan-50 rounded-xl shadow-inner border border-blue-200 mt-4">
            <h3 class="text-xl font-semibold text-gray-700 mb-4 text-center">▶️ Recording Playback</h3>
            <div class="flex flex-col space-y-3">
                <div class="flex space-x-2">
                                    <button id="loadRecordingsBtn" class="btn-primary flex-1">
                    <span class="font-semibold">📋 Load Recordings</span>
                </button>
                <button id="openPlaybackPageBtn" class="btn-primary flex-1">
                    <span class="font-semibold">🎬 Open Playback Page</span>
                </button>
                <button id="playRecordingBtn" class="btn-primary flex-1 hidden">
                    <span class="font-semibold">▶️ Play Recording</span>
                </button>
                    <button id="pauseRecordingBtn" class="btn-secondary flex-1 hidden">
                        <span class="font-semibold">⏸️ Pause</span>
                    </button>
                </div>
                <select id="recordingsList" class="modern-input text-sm hidden">
                    <option value="">Select a recording...</option>
                </select>
                <div id="playbackProgressContainer" class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700 hidden">
                    <div id="playbackProgressBar" class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <span id="playbackStatus" class="text-sm text-gray-600 text-center"></span>
            </div>
        </div>

        <!-- Main Content Area -->
    </div>

    <!-- Teacher's Whiteboard Request & Management Modal -->
    <div id="whiteboardRequestModal" class="modal">
        <div class="modal-content slide-up">
            <span class="close-button">&times;</span>
            <h3 class="text-2xl font-bold mb-6 text-gray-800">Whiteboard Access Management</h3>

            <div class="mb-8">
                <h4 class="text-xl font-semibold mb-4 text-gray-700">⏳ Pending Requests</h4>
                <ul id="pendingRequestList" class="space-y-3 max-h-40 overflow-y-auto border border-gray-200 rounded-lg p-4 bg-gray-50">
                    <!-- Pending requests will be dynamically added here -->
                </ul>
                <p id="noPendingRequestsMessage" class="text-gray-500 mt-3 text-sm">No pending requests.</p>
            </div>

            <div>
                <h4 class="text-xl font-semibold mb-4 text-gray-700">✅ Currently Granted Permissions</h4>
                <ul id="grantedPermissionList" class="space-y-3 max-h-40 overflow-y-auto border border-gray-200 rounded-lg p-4 bg-gray-50">
                    <!-- Granted permissions will be dynamically added here -->
                </ul>
                <p id="noGrantedPermissionsMessage" class="text-gray-500 mt-3 text-sm">No students currently have drawing permission.</p>
            </div>
        </div>
    </div>

    <!-- Screen Share Permission Request Modal -->
    <div id="screenSharePermissionModal" class="modal">
        <div class="modal-content slide-up">
            <span class="close-button" onclick="document.getElementById('screenSharePermissionModal').style.display='none'">&times;</span>
            <h3 class="text-2xl font-bold mb-6 text-gray-800">Screen Share Permission Request</h3>
            
            <div class="mb-6">
                <p class="text-gray-700 mb-4">
                    <span id="screenShareRequesterName" class="font-semibold"></span> 
                    is requesting permission to share their screen.
                </p>
                <p class="text-sm text-gray-600">This will allow them to share their screen with the class.</p>
            </div>

            <div class="flex space-x-4 justify-center">
                <button id="grantScreenShareBtn" class="bg-green-500 hover:bg-green-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                    ✅ Grant Permission
                </button>
                <button id="denyScreenShareBtn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                    ❌ Deny Permission
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Global Variables ---
        const localVideo = document.getElementById('localVideo');
        const remoteVideosContainer = document.getElementById('remoteVideos');
        const usernameInput = document.getElementById('usernameInput');
        const roomInput = document.getElementById('roomInput');
        const createRoomBtn = document.getElementById('createRoomBtn');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const statusMessage = document.getElementById('statusMessage');
        const subjectBanner = document.getElementById('subjectBanner');
        const subjectText = document.getElementById('subjectText');
        const subjectEditContainer = document.getElementById('subjectEditContainer');
        const subjectInput = document.getElementById('subjectInput');
        const setSubjectBtn = document.getElementById('setSubjectBtn');

        const whiteboardContainer = document.getElementById('whiteboardContainer');
        const whiteboardCanvas = document.getElementById('whiteboardCanvas');
        const ctx = whiteboardCanvas.getContext('2d');
        const colorPicker = document.getElementById('colorPicker');
        const clearWhiteboardBtn = document.getElementById('clearWhiteboardBtn');
        const toggleMicBtn = document.getElementById('toggleMicBtn');
        const toggleCamBtn = document.getElementById('toggleCamBtn');

        const drawToolBtn = document.getElementById('drawToolBtn');
        const textToolBtn = document.getElementById('textToolBtn');
        // New shape tool buttons
        const lineToolBtn = document.getElementById('lineToolBtn');
        const rectToolBtn = document.getElementById('rectToolBtn');
        const ellipseToolBtn = document.getElementById('ellipseToolBtn');
        const triangleToolBtn = document.getElementById('triangleToolBtn');
        const graphToolBtn = document.getElementById('graphToolBtn');
        const eraserToolBtn = document.getElementById('eraserToolBtn');

        const fontSizeSelect = document.getElementById('fontSizeSelect');
        const fontFamilySelect = document.getElementById('fontFamilySelect');
        const boldBtn = document.getElementById('boldBtn');
        const italicBtn = document.getElementById('italicBtn');
        const underlineBtn = document.getElementById('underlineBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        const requestWhiteboardAccessBtn = document.getElementById('requestWhiteboardAccessBtn');
        const manageWhiteboardAccessBtn = document.getElementById('manageWhiteboardAccessBtn');
        const createQuizBtn = document.getElementById('createQuizBtn');
        const takeQuizBtn = document.getElementById('takeQuizBtn');

        const whiteboardRequestModal = document.getElementById('whiteboardRequestModal');
        const closeButton = whiteboardRequestModal.querySelector('.close-button');
        const pendingRequestList = document.getElementById('pendingRequestList');
        const noPendingRequestsMessage = document.getElementById('noPendingRequestsMessage');
        const grantedPermissionList = document.getElementById('grantedPermissionList');
        const noGrantedPermissionsMessage = document.getElementById('noGrantedPermissionsMessage');

        // Screen share permission modal elements
        const screenSharePermissionModal = document.getElementById('screenSharePermissionModal');
        const screenShareCloseButton = screenSharePermissionModal.querySelector('.close-button');
        const screenShareRequesterName = document.getElementById('screenShareRequesterName');
        const grantScreenShareBtn = document.getElementById('grantScreenShareBtn');
        const denyScreenShareBtn = document.getElementById('denyScreenShareBtn');

        const teacherInfoDiv = document.getElementById('teacherInfo');
        const teacherNameSpan = document.getElementById('teacherName');
        const classRosterSection = document.getElementById('classRosterSection');
        const classRosterList = document.getElementById('classRosterList');
        const emptyRosterMessage = document.getElementById('emptyRosterMessage');
        const typingIndicator = document.getElementById('typingIndicator');
        const typingTeacherName = document.getElementById('typingTeacherName');
        
        // Graph plotting elements
        const graphInterface = document.getElementById('graphInterface');
        const functionInput = document.getElementById('functionInput');
        const plotFunctionBtn = document.getElementById('plotFunctionBtn');
        const clearGraphBtn = document.getElementById('clearGraphBtn');
        const xMin = document.getElementById('xMin');
        const xMax = document.getElementById('xMax');
        const yMin = document.getElementById('yMin');
        const yMax = document.getElementById('yMax');

        // Recording elements
        const recordingControls = document.getElementById('recordingControls');
        const startRecordingBtn = document.getElementById('startRecordingBtn');
        const stopRecordingBtn = document.getElementById('stopRecordingBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingStatusText = document.getElementById('recordingStatusText');
        const recordVideo = document.getElementById('recordVideo');
        const recordAudio = document.getElementById('recordAudio');
        const recordWhiteboard = document.getElementById('recordWhiteboard');
        const recordScreen = document.getElementById('recordScreen');

        // Playback elements
        const playbackInterface = document.getElementById('playbackInterface');
        const loadRecordingsBtn = document.getElementById('loadRecordingsBtn');
        const openPlaybackPageBtn = document.getElementById('openPlaybackPageBtn');
        const playRecordingBtn = document.getElementById('playRecordingBtn');
        const pauseRecordingBtn = document.getElementById('pauseRecordingBtn');
        const recordingsList = document.getElementById('recordingsList');
        const playbackProgressContainer = document.getElementById('playbackProgressContainer');
        const playbackProgressBar = document.getElementById('playbackProgressBar');
        const playbackStatus = document.getElementById('playbackStatus');
        const showGridBtn = document.getElementById('showGridBtn');
        const autoScaleBtn = document.getElementById('autoScaleBtn');


        let ws; // WebSocket connection
        let localStream; // Local media stream (audio/video)
        let peerConnections = {}; // Store RTCPeerConnection objects
        let currentRoomId = '';
        let username = '';
        let myUserId = ''; // This client's unique ID, assigned by the server
        let teacherId = ''; // Stores the userID of the teacher
        let hasWhiteboardPermission = false; // True if current user has permission to draw
        let isConnected = false; // Track WebSocket connection status

        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let currentColor = '#000000';

        let currentTool = 'draw';
        let currentLineWidth = 2;
        let activeTextArea = null;
        let currentFontSize = fontSizeSelect.value;
        let currentFontFamily = fontFamilySelect.value;
        let isBold = false;
        let isItalic = false;
        let isUnderline = false;

        // New variables for shape drawing
        let startX = 0;
        let startY = 0;
        let isDrawingShape = false;

        let pendingWhiteboardRequests = {};
        let grantedWhiteboardPermissions = {};
        let remoteUsernames = {};
        let whiteboardHistory = [];
        let isEraserActive = false;
        let teacherTypingTimer = null;
        let typingTimer = null;
        
        // Store latest remote MediaStreams by userId for quick switching (teacher vs screen sharer)
        let remoteStreams = {};
        
        // Graph plotting variables
        let showGrid = false;
        let graphFunctions = [];
        let currentGraphColor = '#FF0000';
        
        // File sharing variables
        let sharedFiles = [];
        let fileSharingInterface = document.getElementById('fileSharingInterface');
        
        // Screen sharing variables
        let screenStream = null;
        // Hidden video elements to keep continuous camera/screen frames for compositor
        let hiddenCameraVideo = null;
        let hiddenScreenVideo = null;
        let isScreenSharing = false;
        let screenShareOwnerId = null;
        let screenShareOwnerName = '';
        let screenSharePermission = false; // Whether current user can share screen
        let pendingScreenShareRequest = null; // Store pending screen share permission request
        const fileUploadArea = document.getElementById('fileUploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadProgress = document.getElementById('uploadProgress');
        const progressBar = document.getElementById('progressBar');
        const uploadStatus = document.getElementById('uploadStatus');
        const sharedFilesList = document.getElementById('sharedFilesList');
        const noFilesMessage = document.getElementById('noFilesMessage');
        
        // Screen sharing elements
        const screenShareBtn = document.getElementById('screenShareBtn');
        const stopScreenShareBtn = document.getElementById('stopScreenShareBtn');
        const screenShareStatus = document.getElementById('screenShareStatus');
        const screenShareOwner = document.getElementById('screenShareOwner');
        const screenSharePermissionRequest = document.getElementById('screenSharePermissionRequest');
        const requestScreenShareBtn = document.getElementById('requestScreenShareBtn');

        // Video source toggle elements (for students)
        const videoSourceToggle = document.getElementById('videoSourceToggle');
        const currentVideoSource = document.getElementById('currentVideoSource');
        const showTeacherBtn = document.getElementById('showTeacherBtn');
        const showScreenShareBtn = document.getElementById('showScreenShareBtn');

        // Recording state variables
        let isRecording = false;
        let currentRecordingId = null;
        let recordingStartTime = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStream = null;
        let screenRecordingStream = null;
        let screenMediaRecorder = null;
        let screenRecordedChunks = [];

        // Playback state variables
        let currentPlaybackRecording = null;
        let playbackInterval = null;
        let playbackIndex = 0;
        let isPlaying = false;
        let playbackSpeed = 1;
        let availableRecordings = [];

        // Video source preference for students (teacher or screen sharer)
        let currentVideoSourcePreference = 'teacher'; // 'teacher' or 'screenShare'

        // --- Video Source Toggle Functions (for students) ---
        function showTeacherVideo() {
            if (myUserId === teacherId) return; // Only for students
            
            currentVideoSourcePreference = 'teacher';
            const teacherStream = remoteStreams[teacherId];
            if (localVideo && teacherStream) {
                localVideo.srcObject = teacherStream;
                const localVideoLabel = document.getElementById('localVideoLabel');
                if (localVideoLabel) {
                    const teacherName = (remoteUsernames && remoteUsernames[teacherId]) ? remoteUsernames[teacherId] : 'Teacher';
                    localVideoLabel.textContent = teacherName;
                }
                if (currentVideoSource) {
                    currentVideoSource.textContent = teacherName;
                }
            }
        }

        function showScreenShareVideo() {
            if (myUserId === teacherId) return; // Only for students
            if (!screenShareOwnerId) return; // No one is screen sharing
            
            currentVideoSourcePreference = 'screenShare';
            const screenShareStream = remoteStreams[screenShareOwnerId];
            if (localVideo && screenShareStream) {
                localVideo.srcObject = screenShareStream;
                const localVideoLabel = document.getElementById('localVideoLabel');
                if (localVideoLabel) {
                    const sharerName = (remoteUsernames && remoteUsernames[screenShareOwnerId]) ? remoteUsernames[screenShareOwnerId] : 'Screen Sharer';
                    localVideoLabel.textContent = sharerName + ' (Screen Sharing)';
                }
                if (currentVideoSource) {
                    const sharerName = (remoteUsernames && remoteUsernames[screenShareOwnerId]) ? remoteUsernames[screenShareOwnerId] : 'Screen Share';
                    currentVideoSource.textContent = sharerName;
                }
            }
        }

        function updateVideoSourceToggleVisibility() {
            if (myUserId === teacherId) {
                // Teachers don't need this toggle
                if (videoSourceToggle) videoSourceToggle.classList.add('hidden');
                return;
            }
            
            // Show toggle for students when both teacher and screen share are available
            if (screenShareOwnerId && remoteStreams[teacherId] && remoteStreams[screenShareOwnerId]) {
                if (videoSourceToggle) videoSourceToggle.classList.remove('hidden');
            } else {
                if (videoSourceToggle) videoSourceToggle.classList.add('hidden');
            }
        }

        // --- Utility Functions ---
        function getShapeName(obj) {
            return (obj && (obj.shape || obj.shapeType)) || '';
        }
        function displayStatus(message, type = 'info') {
            statusMessage.textContent = message;
            statusMessage.className = `text-center text-lg mt-4 p-4 rounded-md shadow-inner`;
            if (type === 'info') {
                statusMessage.classList.add('bg-blue-50', 'text-blue-700');
            } else if (type === 'error') {
                statusMessage.classList.add('bg-red-50', 'text-red-700');
            } else if (type === 'success') {
                statusMessage.classList.add('bg-green-50', 'text-green-700');
            }
        }

        function generateRoomId() {
            return Math.random().toString(36).substring(2, 8).toUpperCase();
        }

        function hasActiveWhiteboardPermission() {
            return myUserId === teacherId || hasWhiteboardPermission;
        }

        function resizeCanvas() {
            const parent = whiteboardContainer;
            whiteboardCanvas.width = parent.clientWidth;
            whiteboardCanvas.height = parent.clientHeight;
            redrawWhiteboardHistory();
        }
        


        // --- New drawing functions for shapes ---
        function drawLineOnCanvas(x1, y1, x2, y2, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = currentLineWidth;
            ctx.lineCap = 'round';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawRectOnCanvas(x1, y1, x2, y2, color) {
            const width = x2 - x1;
            const height = y2 - y1;
            ctx.strokeStyle = color;
            ctx.lineWidth = currentLineWidth;
            ctx.strokeRect(x1, y1, width, height);
        }

        function drawEllipseOnCanvas(x1, y1, x2, y2, color) {
            const centerX = (x1 + x2) / 2;
            const centerY = (y1 + y2) / 2;
            const radiusX = Math.abs(x2 - x1) / 2;
            const radiusY = Math.abs(y2 - y1) / 2;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = currentLineWidth;
            ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }

        function drawTriangleOnCanvas(x1, y1, x2, y2, color) {
            const midX = (x1 + x2) / 2;
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = currentLineWidth;
            ctx.moveTo(midX, y1);
            ctx.lineTo(x1, y2);
            ctx.lineTo(x2, y2);
            ctx.closePath();
            ctx.stroke();
        }
        
        // --- Graph plotting functions ---
        function plotFunction(functionText) {
            try {
                // Parse the function and add to graph functions
                const graphFunction = {
                    expression: functionText,
                    color: currentGraphColor,
                    points: []
                };
                
                // Generate points for the function
                const xRange = parseFloat(xMax.value) - parseFloat(xMin.value);
                const step = xRange / 200; // 200 points for smooth curves
                
                for (let x = parseFloat(xMin.value); x <= parseFloat(xMax.value); x += step) {
                    try {
                        const y = evaluateFunction(functionText, x);
                        if (isFinite(y) && y >= parseFloat(yMin.value) && y <= parseFloat(yMax.value)) {
                            const canvasX = ((x - parseFloat(xMin.value)) / xRange) * whiteboardCanvas.width;
                            const canvasY = whiteboardCanvas.height - ((y - parseFloat(yMin.value)) / (parseFloat(yMax.value) - parseFloat(yMin.value))) * whiteboardCanvas.height;
                            graphFunction.points.push({ x: canvasX, y: canvasY });
                        }
                    } catch (e) {
                        // Skip invalid points
                    }
                }
                
                // Add to graph functions array
                graphFunctions.push(graphFunction);
                
                // Draw the function
                drawGraphFunction(graphFunction);
                
                // Add to whiteboard history
                if (ws && ws.readyState === WebSocket.OPEN) {
                    const graphMessage = {
                        type: 'graph-function',
                        expression: functionText,
                        color: currentGraphColor,
                        points: graphFunction.points
                    };
                    console.log('Sending graph-function message:', graphMessage);
                    ws.send(JSON.stringify(graphMessage));
                } else {
                    console.warn('WebSocket not ready or not connected. State:', ws ? ws.readyState : 'no ws');
                }
                
                whiteboardHistory.push({
                    type: 'graph-function',
                    expression: functionText,
                    color: currentGraphColor,
                    points: graphFunction.points
                });
                
                displayStatus(`Function ${functionText} plotted successfully!`, 'success');
                
            } catch (error) {
                displayStatus(`Error plotting function: ${error.message}`, 'error');
            }
        }
        
        function evaluateFunction(functionText, x) {
            // Replace mathematical notation with JavaScript equivalents
            let jsCode = functionText
                .replace(/x\^(\d+)/g, 'Math.pow(x, $1)') // x^2 -> Math.pow(x, 2)
                .replace(/sin\(/g, 'Math.sin(')
                .replace(/cos\(/g, 'Math.cos(')
                .replace(/tan\(/g, 'Math.tan(')
                .replace(/log\(/g, 'Math.log(')
                .replace(/sqrt\(/g, 'Math.sqrt(')
                .replace(/abs\(/g, 'Math.abs(')
                .replace(/e/g, 'Math.E')
                .replace(/pi/g, 'Math.PI');
            
            // Create a safe evaluation function
            const safeEval = new Function('x', `return ${jsCode}`);
            return safeEval(x);
        }
        
        function drawGraphFunction(graphFunction) {
            if (graphFunction.points.length < 2) return;
            
            ctx.beginPath();
            ctx.strokeStyle = graphFunction.color;
            ctx.lineWidth = 2;
            ctx.lineCap = 'round';
            
            const firstPoint = graphFunction.points[0];
            ctx.moveTo(firstPoint.x, firstPoint.y);
            
            for (let i = 1; i < graphFunction.points.length; i++) {
                const point = graphFunction.points[i];
                ctx.lineTo(point.x, point.y);
                ctx.stroke();
            }
            
            ctx.stroke();
        }
        
        function clearGraph() {
            // Remove all graph functions
            graphFunctions = [];
            
            // Clear the canvas and redraw
            ctx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            redrawWhiteboardHistory();
            
            // Notify other users about graph clearing
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'clear-graph'
                }));
            }
            
            displayStatus('Graph cleared!', 'info');
        }
        
        function autoScaleGraph() {
            // Find the range of all plotted functions
            let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
            
            graphFunctions.forEach(func => {
                func.points.forEach(point => {
                    const worldX = parseFloat(xMin.value) + (point.x / whiteboardCanvas.width) * (parseFloat(xMax.value) - parseFloat(xMin.value));
                    const worldY = parseFloat(yMax.value) - (point.y / whiteboardCanvas.height) * (parseFloat(yMax.value) - parseFloat(yMin.value));
                    minX = Math.min(minX, worldX);
                    maxX = Math.max(maxX, worldX);
                    minY = Math.min(minY, worldY);
                    maxY = Math.max(maxY, worldY);
                });
            });
            
            if (isFinite(minX) && isFinite(maxX) && isFinite(minY) && isFinite(maxY)) {
                // Add some padding
                const padding = 0.1;
                const xRange = maxX - minX;
                const yRange = maxY - minY;
                
                xMin.value = (minX - xRange * padding).toFixed(2);
                xMax.value = (maxX + xRange * padding).toFixed(2);
                yMin.value = (minY - yRange * padding).toFixed(2);
                yMax.value = (maxY + yRange * padding).toFixed(2);
                
                // Redraw with new scale
                redrawWhiteboardHistory();
                displayStatus('Graph auto-scaled!', 'info');
            }
        }
        
        function drawCoordinateGrid() {
            if (!showGrid) {
                return;
            }
            
            ctx.strokeStyle = '#E5E7EB';
            ctx.lineWidth = 1;
            
            const xRange = parseFloat(xMax.value) - parseFloat(xMin.value);
            const yRange = parseFloat(yMax.value) - parseFloat(yMin.value);
            
            // Vertical grid lines
            for (let x = parseFloat(xMin.value); x <= parseFloat(xMax.value); x += 1) {
                const canvasX = ((x - parseFloat(xMin.value)) / xRange) * whiteboardCanvas.width;
                ctx.beginPath();
                ctx.moveTo(canvasX, 0);
                ctx.lineTo(canvasX, whiteboardCanvas.height);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            for (let y = parseFloat(yMin.value); y <= parseFloat(yMax.value); y += 1) {
                const canvasY = whiteboardCanvas.height - ((y - parseFloat(yMin.value)) / yRange) * whiteboardCanvas.height;
                ctx.beginPath();
                ctx.moveTo(0, canvasY);
                ctx.lineTo(whiteboardCanvas.width, canvasY);
                ctx.lineTo(whiteboardCanvas.width, canvasY);
                ctx.stroke();
            }
            
            // Axes
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            
            // X-axis
            const xAxisY = whiteboardCanvas.height - ((0 - parseFloat(yMin.value)) / yRange) * whiteboardCanvas.height;
            ctx.beginPath();
            ctx.moveTo(0, xAxisY);
            ctx.lineTo(whiteboardCanvas.width, xAxisY);
            ctx.stroke();
            
            // Y-axis
            const yAxisX = ((0 - parseFloat(xMin.value)) / xRange) * whiteboardCanvas.width;
            ctx.beginPath();
            ctx.moveTo(yAxisX, 0);
            ctx.lineTo(yAxisX, whiteboardCanvas.height);
            ctx.stroke();
        }
        
        // --- File sharing functions ---
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
        
        function getFileIcon(fileType, isImage, isPDF, isDocument) {
            if (isImage) return '🖼️';
            if (isPDF) return '📄';
            if (isDocument) return '📝';
            if (fileType.includes('video')) return '🎥';
            if (fileType.includes('audio')) return '🎵';
            return '📁';
        }
        
        function uploadFile(file) {
            if (!currentRoomId || !myUserId || !username) {
                displayStatus('Cannot upload file: Not connected to a room.', 'error');
                return;
            }
            
            const formData = new FormData();
            formData.append('file', file);
            formData.append('roomId', currentRoomId);
            formData.append('userId', myUserId);
            formData.append('username', username);
            
            // Show upload progress
            uploadProgress.classList.remove('hidden');
            progressBar.style.width = '0%';
            uploadStatus.textContent = 'Uploading...';
            
            const xhr = new XMLHttpRequest();
            
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const percentComplete = (e.loaded / e.total) * 100;
                    progressBar.style.width = percentComplete + '%';
                    uploadStatus.textContent = `Uploading... ${Math.round(percentComplete)}%`;
                }
            });
            
            xhr.addEventListener('load', () => {
                if (xhr.status === 200) {
                    const response = JSON.parse(xhr.responseText);
                    if (response.success) {
                        displayStatus(`File "${file.name}" uploaded successfully!`, 'success');
                        // The file will be added to the list via WebSocket message
                    } else {
                        displayStatus('Upload failed: ' + (response.error || 'Unknown error'), 'error');
                    }
                } else {
                    displayStatus('Upload failed: ' + xhr.statusText, 'error');
                }
                uploadProgress.classList.add('hidden');
            });
            
            xhr.addEventListener('error', () => {
                displayStatus('Upload failed: Network error', 'error');
                uploadProgress.classList.add('hidden');
            });
            
            xhr.open('POST', '/upload');
            xhr.send(formData);
        }
        
        function renderSharedFiles() {
            sharedFilesList.innerHTML = '';
            
            if (sharedFiles.length === 0) {
                noFilesMessage.classList.remove('hidden');
                return;
            }
            
            noFilesMessage.classList.add('hidden');
            
            sharedFiles.forEach(file => {
                const fileItem = document.createElement('div');
                fileItem.className = 'flex items-center justify-between p-3 bg-white rounded-lg border border-gray-200 hover:shadow-md transition-shadow';
                fileItem.dataset.fileId = file.id;
                
                const fileIcon = getFileIcon(file.type, file.isImage, file.isPDF, file.isDocument);
                const fileSize = formatFileSize(file.size);
                const uploadDate = new Date(file.uploadedAt).toLocaleDateString();
                
                fileItem.innerHTML = `
                    <div class="flex items-center space-x-3">
                        <span class="text-2xl">${fileIcon}</span>
                        <div>
                            <p class="font-medium text-gray-800">${file.name}</p>
                            <p class="text-sm text-gray-500">${fileSize} • Uploaded by ${file.uploadedBy} on ${uploadDate}</p>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button class="download-btn bg-blue-500 text-white px-3 py-1 rounded text-sm hover:bg-blue-600 transition-colors">
                            📥 Download
                        </button>
                        ${myUserId === teacherId ? `
                            <button class="delete-btn bg-red-500 text-white px-3 py-1 rounded text-sm hover:bg-red-600 transition-colors">
                                🗑️ Delete
                            </button>
                        ` : ''}
                    </div>
                `;
                
                sharedFilesList.appendChild(fileItem);
            });
        }
        
        function addSharedFile(fileInfo) {
            // Check if file already exists
            const existingIndex = sharedFiles.findIndex(f => f.id === fileInfo.id);
            if (existingIndex !== -1) {
                sharedFiles[existingIndex] = fileInfo;
            } else {
                sharedFiles.push(fileInfo);
            }
            renderSharedFiles();
        }
        
        function removeSharedFile(fileId) {
            sharedFiles = sharedFiles.filter(f => f.id !== fileId);
            renderSharedFiles();
        }


        function redrawWhiteboardHistory() {
            ctx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            
            // Clear and rebuild graph functions array from history
            graphFunctions = [];
            
            if (whiteboardHistory && whiteboardHistory.length > 0) {
                whiteboardHistory.forEach(item => {
                    if (item.type === 'draw') {
                        const prevWidth = currentLineWidth;
                        currentLineWidth = item.lineWidth || 2;
                        drawLineOnCanvas(item.x1, item.y1, item.x2, item.y2, item.color);
                        currentLineWidth = prevWidth;
                    } else if (item.type === 'text') {
                        drawTextOnCanvas(
                            item.textContent,
                            item.textX,
                            item.textY,
                            item.color,
                            item.fontSize,
                            item.fontFamily,
                            item.fontWeight,
                            item.fontStyle,
                            item.textDecoration
                        );
                    } else if (item.type === 'shape') { // New shape type
                        switch (getShapeName(item)) {
                            case 'line':
                                const prevW = currentLineWidth;
                                currentLineWidth = item.lineWidth || 2;
                                drawLineOnCanvas(item.x1, item.y1, item.x2, item.y2, item.color);
                                currentLineWidth = prevW;
                                break;
                            case 'rect':
                                drawRectOnCanvas(item.x1, item.y1, item.x2, item.y2, item.color);
                                break;
                            case 'ellipse':
                                drawEllipseOnCanvas(item.x1, item.y1, item.x2, item.y2, item.color);
                                break;
                            case 'triangle':
                                drawTriangleOnCanvas(item.x1, item.y1, item.x2, item.y2, item.color);
                                break;
                        }
                    } else if (item.type === 'graph-function') {
                        // Rebuild graph functions array and redraw
                        if (item.expression && item.points) {
                            const graphFunction = {
                                expression: item.expression,
                                color: item.color || '#FF0000',
                                points: item.points
                            };
                            graphFunctions.push(graphFunction);
                            drawGraphFunction(graphFunction);
                        }
                    }
                });
            }
            
            // Only draw coordinate grid if there are graph functions or if grid is explicitly enabled
            if (graphFunctions.length > 0 || showGrid) {
                drawCoordinateGrid();
            }
        }

        function updateWhiteboardPermissionState(newPermissionState) {
            hasWhiteboardPermission = newPermissionState;
            console.log(`[PERMISSION_UPDATE] My permission has been set to: ${hasWhiteboardPermission}.`);

            if (hasWhiteboardPermission) {
                whiteboardCanvas.classList.remove('disabled');
                requestWhiteboardAccessBtn.textContent = '✅ Whiteboard Granted';
                requestWhiteboardAccessBtn.disabled = true;
                displayStatus('You have permission to draw on the whiteboard!', 'success');
            } else {
                whiteboardCanvas.classList.add('disabled');
                requestWhiteboardAccessBtn.textContent = '✋ Request Whiteboard';
                requestWhiteboardAccessBtn.disabled = false;
                displayStatus('Whiteboard access is currently restricted. Request permission from the teacher.', 'info');
            }
        }

        function updateUIState() {
            if (isConnected) {
                usernameInput.disabled = true;
                roomInput.disabled = true;
                createRoomBtn.disabled = true;
                joinRoomBtn.disabled = true;
            } else {
                usernameInput.disabled = false;
                roomInput.disabled = false;
                createRoomBtn.disabled = false;
                joinRoomBtn.disabled = false;
            }

            if (myUserId === teacherId) {
                subjectEditContainer.classList.remove('hidden');
                whiteboardCanvas.classList.remove('disabled');
                requestWhiteboardAccessBtn.classList.add('hidden');
                manageWhiteboardAccessBtn.classList.remove('hidden');
                
                // Show teacher quiz button, hide student quiz button
                createQuizBtn.classList.remove('hidden');
                takeQuizBtn.classList.add('hidden');

                noPendingRequestsMessage.classList.toggle('hidden', Object.keys(pendingWhiteboardRequests).length > 0);
                noGrantedPermissionsMessage.classList.toggle('hidden', Object.keys(grantedWhiteboardPermissions).length > 0);
                
                // Teachers can always share screen
                screenSharePermission = true;
                screenSharePermissionRequest.classList.add('hidden');
                
                // Show recording controls for teachers
                recordingControls.classList.remove('hidden');
            } else {
                subjectEditContainer.classList.add('hidden');
                requestWhiteboardAccessBtn.classList.remove('hidden');
                manageWhiteboardAccessBtn.classList.add('hidden');
                whiteboardRequestModal.style.display = 'none';
                
                // Show student quiz button, hide teacher quiz button
                createQuizBtn.classList.add('hidden');
                takeQuizBtn.classList.remove('hidden');

                whiteboardCanvas.classList.toggle('disabled', !hasWhiteboardPermission);
                
                // Students need permission to share screen
                if (!screenSharePermission) {
                    screenSharePermissionRequest.classList.remove('hidden');
                } else {
                    screenSharePermissionRequest.classList.add('hidden');
                }
                
                // Hide recording controls for students
                recordingControls.classList.add('hidden');
            }
            
            // Show playback interface for all users
            playbackInterface.classList.remove('hidden');
            
            // Highlight the active tool
            const tools = [drawToolBtn, textToolBtn, lineToolBtn, rectToolBtn, ellipseToolBtn, triangleToolBtn, graphToolBtn, fileSharingToolBtn];
            tools.push(eraserToolBtn);
            tools.forEach(btn => btn.classList.remove('tool-active'));
            switch (currentTool) {
                case 'draw':
                    drawToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
                case 'text':
                    textToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'text' : 'not-allowed';
                    break;
                case 'line':
                    lineToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
                case 'rect':
                    rectToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
                case 'ellipse':
                    ellipseToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
                case 'triangle':
                    document.getElementById(`${currentTool}ToolBtn`).classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
                case 'eraser':
                    eraserToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
                case 'graph':
                    graphToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
                case 'files':
                    fileSharingToolBtn.classList.add('tool-active');
                    whiteboardCanvas.style.cursor = hasActiveWhiteboardPermission() ? 'crosshair' : 'not-allowed';
                    break;
            }

            // Also update video UI by role
            updateVideoUIByRole();
        }

        function updateVideoUIByRole() {
            const localVideoContainer = localVideo ? localVideo.parentElement : null;
            const localVideoLabel = document.getElementById('localVideoLabel');
            const videoStreamsHeader = document.getElementById('videoStreamsHeader');
            const remoteVideosContainer = document.getElementById('remoteVideos');
            if (!localVideoContainer) return;
            
            if (myUserId && teacherId && myUserId !== teacherId) {
                // Student: show the local video container for teacher's video
                localVideoContainer.style.display = '';
                if (localVideo) {
                    localVideo.style.display = '';
                }
                // Hide remote videos container for students (they only see teacher)
                if (remoteVideosContainer) {
                    remoteVideosContainer.style.display = 'none';
                }
                // Update label to show "Teacher" when teacher's video is shown
                if (localVideoLabel) {
                    localVideoLabel.textContent = 'Teacher';
                }
                // Update header for students
                if (videoStreamsHeader) {
                    videoStreamsHeader.textContent = '👨‍🏫 Teacher Video';
                }
            } else {
                // Teacher: show self view with reduced size
                localVideoContainer.style.display = '';
                localVideoContainer.classList.add('teacher-video');
                if (localVideo) {
                    localVideo.style.display = '';
                }
                // Show remote videos container for teachers
                if (remoteVideosContainer) {
                    remoteVideosContainer.style.display = 'grid';
                }
                // Update label to show "You" for teacher
                if (localVideoLabel) {
                    localVideoLabel.textContent = 'You';
                }
                // Update header for teachers
                if (videoStreamsHeader) {
                    videoStreamsHeader.textContent = '📹 Video Streams';
                }
            }
        }

        function updateClassRosterUI(roster) {
            classRosterList.innerHTML = '';
            emptyRosterMessage.classList.remove('hidden');

            if (myUserId === teacherId) {
                teacherInfoDiv.classList.add('hidden');
                classRosterSection.classList.remove('hidden');

                let hasOtherParticipants = false;
                roster.forEach(entry => {
                    if (entry.userId === myUserId) {
                        const listItem = document.createElement('li');
                        listItem.className = 'flex items-center justify-between p-2 bg-indigo-50 rounded-md shadow-sm';
                        listItem.innerHTML = `
                            <span class="font-semibold text-indigo-700">🧑‍🏫 ${entry.username} (You, Teacher)</span>
                        `;
                        classRosterList.appendChild(listItem);
                    } else {
                        hasOtherParticipants = true;
                        const listItem = document.createElement('li');
                        listItem.className = 'flex items-center justify-between p-2 bg-gray-100 rounded-md shadow-sm';
                        listItem.innerHTML = `
                            <span class="text-gray-800">🧑‍🎓 ${entry.username}</span>
                        `;
                        classRosterList.appendChild(listItem);
                    }
                });

                if (hasOtherParticipants || roster.length > 1) {
                    emptyRosterMessage.classList.add('hidden');
                } else if (roster.length === 1 && roster[0].userId === myUserId) {
                    emptyRosterMessage.classList.remove('hidden');
                }
            } else {
                teacherInfoDiv.classList.remove('hidden');
                classRosterSection.classList.add('hidden');

                const teacherEntry = roster.find(entry => entry.userId === teacherId);
                if (teacherEntry) {
                    teacherNameSpan.textContent = teacherEntry.username;
                } else {
                    teacherNameSpan.textContent = 'N/A (Teacher not found)';
                }
            }
        }

        function addPendingRequest(userId, username) {
            // --- NEW DEBUGGING LOG ---
            console.log(`[DEBUG] Adding pending request. userId received: ${userId}, username: ${username}`);
            if (!userId) {
                console.error('[DEBUG] userId is invalid. Cannot add request.');
                return;
            }

            if (pendingWhiteboardRequests[userId] || grantedWhiteboardPermissions[userId]) return;

            const listItem = document.createElement('li');
            listItem.id = `request-${userId}`;
            listItem.className = 'flex items-center justify-between p-2 border-b border-gray-200 last:border-b-0';
            listItem.dataset.userId = userId;
            listItem.dataset.username = username;

            listItem.innerHTML = `
                <span>${username} wants to draw.</span>
                <div>
                    <button class="grant-btn bg-green-500 text-white px-3 py-1 rounded-md text-sm hover:bg-green-600 mr-2">Grant</button>
                    <button class="deny-btn bg-red-500 text-white px-3 py-1 rounded-md text-sm hover:bg-red-600">Deny</button>
                </div>
            `;
            pendingRequestList.appendChild(listItem);
            pendingWhiteboardRequests[userId] = { username, element: listItem };
            updateUIState();

            whiteboardRequestModal.style.display = 'flex';
        }

        function removePendingRequest(userId) {
            if (pendingWhiteboardRequests[userId]) {
                pendingWhiteboardRequests[userId].element.remove();
                delete pendingWhiteboardRequests[userId];
            }
            updateUIState();
        }

        function addGrantedPermission(userId, username) {
            if (grantedWhiteboardPermissions[userId]) return;

            const listItem = document.createElement('li');
            listItem.id = `granted-${userId}`;
            listItem.className = 'flex items-center justify-between p-2 border-b border-gray-200 last:border-b-0';
            listItem.dataset.userId = userId;
            listItem.dataset.username = username;

            listItem.innerHTML = `
                <span>${username}</span>
                <button class="revoke-btn bg-red-500 text-white px-3 py-1 rounded-md text-sm hover:bg-red-600">Revoke</button>
            `;
            grantedPermissionList.appendChild(listItem);
            grantedWhiteboardPermissions[userId] = { username, element: listItem };
            updateUIState();
        }

        function removeGrantedPermission(userId) {
            if (grantedWhiteboardPermissions[userId]) {
                grantedWhiteboardPermissions[userId].element.remove();
                delete grantedWhiteboardPermissions[userId];
            }
            updateUIState();
        }

        // --- WebSocket Setup ---
        function initWebSocket(roomId, userName) {
            ws = new WebSocket(`ws://localhost:8888/ws?room=${roomId}&username=${userName}`);

            ws.onopen = () => {
                displayStatus(`Connected to room: ${roomId} as ${userName}`, 'success');
                console.log('WebSocket connected');
                isConnected = true;
                updateUIState();
            };

            ws.onmessage = async (event) => {
                const message = JSON.parse(event.data);
                console.log('WebSocket message received:', message);

                switch (message.type) {
                    case 'assigned-id':
                        myUserId = message.userId;
                        teacherId = message.teacherId;
                        updateWhiteboardPermissionState(message.hasPermission);
                        // Set screen sharing permission
                        screenSharePermission = message.hasScreenSharePermission || false;
                        console.log(`[STATE CHANGE] My assigned User ID: ${myUserId}, Teacher ID: ${teacherId}`);
                        console.log(`[STATE CHANGE] Initial Permission status: ${hasWhiteboardPermission}`);
                        console.log(`[STATE CHANGE] Screen Share Permission status: ${screenSharePermission}`);

                        remoteUsernames[myUserId] = username;

                        if (message.whiteboardHistory) {
                            whiteboardHistory = message.whiteboardHistory;
                            displayStatus('Loading whiteboard history...', 'info');
                            redrawWhiteboardHistory();
                            displayStatus('Whiteboard history loaded.', 'success');
                        }

                        if (message.currentRoster) {
                            message.currentRoster.forEach(entry => {
                                remoteUsernames[entry.userId] = entry.username;
                            });
                            updateClassRosterUI(message.currentRoster);
                        }

                        if (message.sharedFiles) {
                            sharedFiles = message.sharedFiles;
                            renderSharedFiles();
                        }

                        updateUIState();
                        if (message.subject) {
                            console.log(`[SUBJECT] Received subject in assigned-id: ${message.subject}`);
                            subjectText.textContent = `Subject: ${message.subject}`;
                        }
                        // Ensure video role UI is applied once IDs are known
                        updateVideoUIByRole();
                        break;
                    case 'subject-updated':
                        console.log(`[SUBJECT] Received subject-updated: ${message.subject}`);
                        subjectText.textContent = `Subject: ${message.subject || ''}`;
                        break;
                    case 'typing-status':
                        console.log(`[TYPING] Received typing status:`, message);
                        console.log(`[TYPING] myUserId: ${myUserId}, teacherId: ${teacherId}, message.userId: ${message.userId}`);
                        if (message.isTyping && message.userId === teacherId) {
                            console.log(`[TYPING] Showing typing indicator for teacher: ${message.username}`);
                            showTeacherTyping(message.username);
                        } else if (!message.isTyping && message.userId === teacherId) {
                            console.log(`[TYPING] Hiding typing indicator for teacher: ${message.username}`);
                            hideTeacherTyping();
                        }
                        break;
                    case 'user-joined':
                        remoteUsernames[message.userId] = message.username;
                        if (message.userId !== myUserId) {
                             displayStatus(`${message.username} joined the class!`, 'info');
                             createPeerConnection(message.userId, true, message.username);
                        }
                        // Patch: If message.currentRoster exists, create peer connections to all users in the roster (except self)
                        if (message.currentRoster) {
                            message.currentRoster.forEach(entry => {
                                if (entry.userId !== myUserId && !peerConnections[entry.userId]) {
                                    createPeerConnection(entry.userId, true, entry.username);
                                }
                            });
                        }
                        if (message.teacherId) teacherId = message.teacherId;
                        if (message.currentRoster) {
                            updateClassRosterUI(message.currentRoster);
                        }
                        // Update subject display when someone joins (in case subject was set before)
                        if (message.subject) {
                            console.log(`[SUBJECT] Received subject in user-joined: ${message.subject}`);
                            subjectText.textContent = `Subject: ${message.subject}`;
                        }
                        updateUIState();
                        break;
                    case 'user-left':
                        displayStatus(`${message.username} left the class.`, 'info');
                        if (peerConnections[message.userId]) {
                            peerConnections[message.userId].close();
                            delete peerConnections[message.userId];
                            document.getElementById(`video-${message.userId}`)?.parentElement.remove();
                            if (Object.keys(peerConnections).length === 0) {
                                remoteVideosContainer.innerHTML = `<div class="video-container bg-gray-200 flex items-center justify-center text-gray-500 text-lg rounded-lg shadow-md">
                                    Waiting for remote participants...
                                </div>`;
                            }
                        }
                        delete remoteUsernames[message.userId];
                        removePendingRequest(message.userId);
                        removeGrantedPermission(message.userId);
                        if (message.currentRoster) {
                            updateClassRosterUI(message.currentRoster);
                        }
                        updateUIState();
                        break;
                    case 'offer':
                        const pcOffer = createPeerConnection(message.from, false, remoteUsernames[message.from]);
                        await pcOffer.setRemoteDescription(new RTCSessionDescription(message.sdp));
                        const answer = await pcOffer.createAnswer();
                        await pcOffer.setLocalDescription(answer);
                        ws.send(JSON.stringify({ type: 'answer', to: message.from, sdp: answer }));
                        break;
                    case 'answer':
                        if (peerConnections[message.from]) {
                            await peerConnections[message.from].setRemoteDescription(new RTCSessionDescription(message.sdp));
                        }
                        break;
                    case 'candidate':
                        if (peerConnections[message.from] && message.candidate) {
                            try {
                                await peerConnections[message.from].addIceCandidate(new RTCIceCandidate(message.candidate));
                            } catch (e) {
                                console.error('Error adding received ICE candidate:', e);
                            }
                        }
                        break;
                    case 'draw':
                        const prevWidth = currentLineWidth;
                        currentLineWidth = message.lineWidth || 2;
                        drawLineOnCanvas(message.x1, message.y1, message.x2, message.y2, message.color);
                        currentLineWidth = prevWidth;
                        whiteboardHistory.push(message);
                        break;
                    case 'text':
                        drawTextOnCanvas(
                            message.textContent,
                            message.textX,
                            message.textY,
                            message.color,
                            message.fontSize,
                            message.fontFamily,
                            message.fontWeight,
                            message.fontStyle,
                            message.textDecoration
                        );
                        whiteboardHistory.push(message);
                        break;
                    case 'shape': // New case for shapes
                        switch (getShapeName(message)) {
                            case 'line':
                                const prevW = currentLineWidth;
                                currentLineWidth = message.lineWidth || 2;
                                drawLineOnCanvas(message.x1, message.y1, message.x2, message.y2, message.color);
                                currentLineWidth = prevW;
                                break;
                            case 'rect':
                                drawRectOnCanvas(message.x1, message.y1, message.x2, message.y2, message.color);
                                break;
                            case 'ellipse':
                                drawEllipseOnCanvas(message.x1, message.y1, message.x2, message.y2, message.color);
                                break;
                            case 'triangle':
                                drawTriangleOnCanvas(message.x1, message.y1, message.x2, message.y2, message.color);
                                break;
                            default:
                                // Fallback for older servers not sending `shape`.
                                drawLineOnCanvas(message.x1, message.y1, message.x2, message.y2, message.color);
                                break;
                        }
                        whiteboardHistory.push(message);
						break;
					case 'graph-function':
						// Handle incoming graph function from other users
						console.log('Received graph-function message:', message);
						if (message.expression && message.points) {
							// Add to local graph functions array
							const graphFunction = {
								expression: message.expression,
								color: message.color || '#FF0000',
								points: message.points
							};
							console.log('Processing graph function:', graphFunction);
							graphFunctions.push(graphFunction);
							
							// Draw the function on canvas
							drawGraphFunction(graphFunction);
							
							// Add to whiteboard history
							whiteboardHistory.push(message);
							console.log('Graph function added to history. Total functions:', graphFunctions.length);
						} else {
							console.warn('Invalid graph-function message:', message);
						}
                        break;
                    case 'whiteboard-history':
                        if (Array.isArray(message.whiteboardHistory)) {
                            whiteboardHistory = message.whiteboardHistory;
                            redrawWhiteboardHistory();
                        }
                        break;
                    case 'clear-whiteboard':
                        whiteboardHistory = [];
                        clearCanvas();
                        break;
                    case 'clear-graph':
                        // Clear graph functions and redraw
                        graphFunctions = [];
                        redrawWhiteboardHistory();
                        break;
                    case 'file-shared':
                        // Handle new file shared
                        const fileInfo = {
                            id: message.fileId,
                            name: message.fileName,
                            size: message.fileSize,
                            type: message.fileType,
                            uploadedBy: message.fileUploadedBy,
                            uploadedAt: message.fileUploadedAt,
                            isImage: message.fileType && message.fileType.startsWith('image/'),
                            isPDF: message.fileType === 'application/pdf',
                            isDocument: message.fileType && message.fileType.startsWith('application/') && 
                                (message.fileType.includes('word') || message.fileType.includes('excel') || 
                                 message.fileType.includes('powerpoint') || message.fileType.includes('document'))
                        };
                        addSharedFile(fileInfo);
                        displayStatus(`File "${fileInfo.name}" shared by ${fileInfo.uploadedBy}!`, 'success');
                        break;
                    case 'file-deleted':
                        // Handle file deleted
                        removeSharedFile(message.fileId);
                        displayStatus('File deleted by teacher.', 'info');
                        break;
                    case 'shared-files':
                        // Handle initial shared files list
                        if (message.sharedFiles) {
                            sharedFiles = message.sharedFiles;
                            renderSharedFiles();
                        }
                        break;
                    case 'request-whiteboard-access':
                        // FIX: Corrected targetUserID to targetUserId
                        if (myUserId === teacherId) {
                            displayStatus(`${message.targetUsername} requested whiteboard access!`, 'info');
                            addPendingRequest(message.targetUserId, message.targetUsername);
                        }
                        break;
                    case 'whiteboard-permission-changed':
                        // FIX: Corrected targetUserID to targetUserId
                        console.log(`[PERM_CHANGE_MSG] Received a permission change message for user: ${message.targetUserId}. New state is ${message.hasPermission}.`);
                        if (message.targetUserId === myUserId) {
                            updateWhiteboardPermissionState(message.hasPermission);
                        }

                        if (myUserId === teacherId) {
                            if (message.hasPermission) {
                                addGrantedPermission(message.targetUserId, message.targetUsername);
                                removePendingRequest(message.targetUserId);
                            } else {
                                removeGrantedPermission(message.targetUserId);
                            }
                        }
                        updateUIState();
                        break;
                    case 'error':
                        displayStatus(`Server Error: ${message.payload}`, 'error');
                        break;
                    case 'screen_share_start':
                        // Handle screen sharing started by another user
                        console.log("[DEBUG] Received screen_share_start message:", message);
                        isScreenSharing = true;
                        screenShareOwnerId = message.userId;
                        screenShareOwnerName = message.username;
                        updateScreenShareStatus(message.userId, message.username, true);
                        displayStatus(`${message.username} started sharing their screen!`, 'success');
                        // Update video source toggle visibility for students
                        updateVideoSourceToggleVisibility();
                        
    // If this is a student and the teacher is sharing, update the video display
    if (myUserId !== teacherId && message.userId === teacherId) {
        // The teacher's screen share will come through the WebRTC track
        // We just need to ensure the UI shows it's screen sharing
        console.log('Teacher started screen sharing - waiting for WebRTC track');
        updateVideoUIByRole(); // Force UI update to ensure correct video stream is displayed
    }
    break;
                    case 'screen_share_stop':
                        // Handle screen sharing stopped by another user
                        isScreenSharing = false;
                        const previousOwner = screenShareOwnerId;
                        screenShareOwnerId = null;
                        screenShareOwnerName = '';
                        updateScreenShareStatus(null, null, false);
                        displayStatus(`${message.username} stopped sharing their screen.`, 'info');
                        
                        // For students: restore teacher's video when screen sharing stops
                        if (myUserId !== teacherId) {
                            const localVideoContainer = localVideo ? localVideo.parentElement : null;
                            if (localVideoContainer) {
                                localVideoContainer.style.display = '';
                                const teacherStream = remoteStreams[teacherId];
                                if (localVideo && teacherStream) {
                                    localVideo.srcObject = teacherStream;
                                }
                                const localVideoLabel = document.getElementById('localVideoLabel');
                                if (localVideoLabel) {
                                    const teacherName = (remoteUsernames && remoteUsernames[teacherId]) ? remoteUsernames[teacherId] : 'Teacher';
                                    localVideoLabel.textContent = teacherName;
                                }
                            }
                            // Update video source toggle visibility
                            updateVideoSourceToggleVisibility();
                        }
                        break;
                    case 'screen_share_permission_granted':
                        // Handle screen sharing permission granted
                        screenSharePermission = true;
                        screenSharePermissionRequest.classList.add('hidden');
                        displayStatus('Screen sharing permission granted by teacher!', 'success');
                        break;
                    case 'screen_share_permission_denied':
                        // Handle screen sharing permission denied
                        screenSharePermission = false;
                        displayStatus('Screen sharing permission denied by teacher.', 'error');
                        break;
                    case 'screen_share_permission_request':
                        // Handle screen sharing permission request (teacher only)
                        if (myUserId === teacherId) {
                            // Store the pending request and show the modal
                            pendingScreenShareRequest = {
                                userId: message.targetUserId,
                                username: message.targetUsername
                            };
                            console.log("[DEBUG] pendingScreenShareRequest set: ", pendingScreenShareRequest);
                            screenShareRequesterName.textContent = message.username;
                            screenSharePermissionModal.style.display = 'flex';
                        }
                        break;
                    case 'teacher-assigned':
                        // Handle when this client is assigned as the new teacher
                        if (message.userId === myUserId) {
                            teacherId = myUserId;
                            displayStatus('You are now the teacher of this room!', 'success');
                            updateUIState();
                        }
                        break;
                    case 'teacher-changed':
                        // Handle when a new teacher is assigned
                        teacherId = message.teacherId;
                        displayStatus(`${message.username} is now the teacher of this room.`, 'info');
                        updateUIState();
                        break;
                    case 'recording-started':
                        // Handle recording started notification
                        if (message.recordingId) {
                            console.log('Setting currentRecordingId to:', message.recordingId);
                            currentRecordingId = message.recordingId;
                            console.log('Recording ID received:', currentRecordingId);
                        }
                        if (myUserId === teacherId) {
                            displayStatus('Recording started successfully', 'success');
                        } else {
                            displayStatus('Recording started by teacher', 'info');
                        }
                        break;
                    case 'recording-stopped':
                        // Handle recording stopped notification
                        console.log('WebSocket recording-stopped received, clearing currentRecordingId. Previous ID:', currentRecordingId);
                        currentRecordingId = null;
                        displayStatus('Recording stopped by teacher', 'info');
                        break;
                    case 'recordings-list':
                        // Handle recordings list response
                        if (message.recordings) {
                            availableRecordings = message.recordings;
                            updateRecordingsList(message.recordings);
                            displayStatus(`Loaded ${message.recordings.length} recordings`, 'success');
                        }
                        break;
                    case 'recording-loaded':
                        // Handle recording loaded response
                        if (message.payload) {
                            currentPlaybackRecording = message.payload;
                            console.log('Recording loaded:', message.payload);
                            console.log('Recording URLs:', {
                                videoUrl: message.payload.videoUrl,
                                audioUrl: message.payload.audioUrl,
                                screenShareUrl: message.payload.screenShareUrl,
                                whiteboardDataCount: message.payload.whiteboardData ? message.payload.whiteboardData.length : 0
                            });
                            playRecordingBtn.classList.remove('hidden');
                            displayStatus('Recording loaded successfully', 'success');
                        }
                        break;
                    default:
                        console.warn('Unknown message type:', message.type);
                }
            };

            ws.onclose = (event) => {
                displayStatus('Disconnected from server.', 'error');
                console.log('WebSocket disconnected:', event.code, event.reason);
                isConnected = false;
                ws = null;
                for (const userId in peerConnections) {
                    peerConnections[userId].close();
                    delete peerConnections[userId];
                    document.getElementById(`video-${userId}`)?.parentElement.remove();
                }
                remoteVideosContainer.innerHTML = `<div class="video-container bg-gray-200 flex items-center justify-center text-gray-500 text-lg rounded-lg shadow-md">
                    Waiting for remote participants...
                </div>`;
                pendingWhiteboardRequests = {};
                grantedWhiteboardPermissions = {};
                remoteUsernames = {};
                whiteboardHistory = [];
                pendingRequestList.innerHTML = '';
                grantedPermissionList.innerHTML = '';
                noPendingRequestsMessage.classList.remove('hidden');
                noGrantedPermissionsMessage.classList.remove('hidden');
                whiteboardRequestModal.style.display = 'none';
                screenSharePermissionModal.style.display = 'none';
                pendingScreenShareRequest = null;
                teacherId = '';
                myUserId = '';
                hasWhiteboardPermission = false;
                updateUIState();
                updateClassRosterUI([]);
                ctx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            };

            ws.onerror = (error) => {
                displayStatus('WebSocket error. Check server status.', 'error');
                console.error('WebSocket error:', error);
            };
        }

        // --- WebRTC Setup ---
        async function initLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                localVideo.srcObject = localStream;
                // Ensure compositor gets continuous camera frames regardless of UI switches
                try { ensureHiddenCameraVideo(); } catch (_) {}
                displayStatus('Local video and audio started.', 'success');
            } catch (error) {
                console.error('Error accessing media devices:', error);
                displayStatus('Could not access camera/microphone. Please allow permissions.', 'error');
            }
        }

        function createPeerConnection(userId, isInitiator, remotePeerUsername = '') {
            if (peerConnections[userId]) {
                return peerConnections[userId];
            }

            const pc = new RTCPeerConnection({
                iceServers: [
                    { urls: 'stun:stun.l.google.com:19302' },
                ]
            });

            // Add tracks to peer connection
            if (localStream) {
                localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
            } else {
                console.warn('Local stream not available when creating peer connection.');
            }

            // If screen sharing is active, add screen track instead of video track
            if (window.currentScreenStream && isScreenSharing && screenShareOwnerId === myUserId) {
                const screenTrack = window.currentScreenStream.getVideoTracks()[0];
                if (screenTrack) {
                    // Remove video track and add screen track
                    const senders = pc.getSenders();
                    const videoSender = senders.find(sender => 
                        sender.track && sender.track.kind === 'video'
                    );
                    if (videoSender) {
                        pc.removeTrack(videoSender);
                    }
                    pc.addTrack(screenTrack, window.currentScreenStream);
                    console.log('Added screen track to new peer connection for', userId);
                }
            }

            pc.ontrack = (event) => {
                // If this client is a student, render the stream of the teacher OR the current screen share owner
                const isStudent = myUserId && teacherId && myUserId !== teacherId;
                // For students: show teacher's stream OR screen sharer's stream (regardless of who is sharing)
                if (isStudent && userId !== teacherId && userId !== screenShareOwnerId) {
                    console.log('Ignoring non-teacher and non-screen-share-owner remote track for student view:', userId);
                    return;
                }

                console.log('Remote track received:', event.streams[0]);
                // Store latest remote stream for this user
                try { remoteStreams[userId] = event.streams[0]; } catch (e) { console.warn('Could not cache remote stream for', userId, e); }
                // Update video source toggle visibility for students
                updateVideoSourceToggleVisibility();
                let remoteVideo = document.getElementById(`video-${userId}`);
                if (!remoteVideo) {
                    const placeholder = remoteVideosContainer.querySelector('.bg-gray-200');
                    if (placeholder) placeholder.remove();

                    const newVideoContainer = document.createElement('div');
                    newVideoContainer.className = 'video-container';
                    const displayUsername = remotePeerUsername || remoteUsernames[userId] || userId.substring(0, 6) + '...';
                    
                    // For students, show teacher's video OR screen sharer's video in the main video container
                    if (isStudent && (userId === teacherId || userId === screenShareOwnerId)) {
                        // Replace the local video container with teacher's or screen sharer's video
                        const localVideoContainer = localVideo ? localVideo.parentElement : null;
                        if (localVideoContainer) {
                            localVideoContainer.style.display = '';
                            if (localVideo) {
                                // Always set the stream for screen sharing or teacher's video
                                localVideo.srcObject = event.streams[0];
                                localVideo.style.display = '';
                            }
                            // Update label to show the correct name and sharing status
                            const localVideoLabel = document.getElementById('localVideoLabel');
                            if (localVideoLabel) {
                                let labelName = remoteUsernames && remoteUsernames[userId] ? remoteUsernames[userId] : (userId === teacherId ? 'Teacher' : 'Screen Sharer');
                                if (isScreenSharing && screenShareOwnerId === userId) {
                                    localVideoLabel.textContent = labelName + ' (Screen Sharing)';
                                } else {
                                    localVideoLabel.textContent = labelName;
                                }
                            }
                        }
                        return;
                    }
                    
                    newVideoContainer.innerHTML = `
                        <video id="video-${userId}" autoplay playsinline class="rounded-lg shadow-md"></video>
                        <div class="absolute bottom-2 left-2 bg-black bg-opacity-50 text-white text-xs px-2 py-1 rounded-md">
                            ${displayUsername}
                        </div>
                    `;
                    remoteVideosContainer.appendChild(newVideoContainer);
                    remoteVideo = document.getElementById(`video-${userId}`);
                }
                remoteVideo.srcObject = event.streams[0];
            };

            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: 'candidate',
                        to: userId,
                        candidate: event.candidate
                    }));
                }
            };

            pc.oniceconnectionstatechange = () => {
                console.log(`ICE connection state for ${userId}:`, pc.iceConnectionState);
                const displayUsername = remotePeerUsername || remoteUsernames[userId] || userId.substring(0, 6) + '...';
                displayStatus(`Connection with ${displayUsername}: ${pc.iceConnectionState}`, 'info');
            };

            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'disconnected') {
                    const videoElement = document.getElementById(`video-${userId}`);
                    if (videoElement && videoElement.parentElement) {
                        videoElement.parentElement.remove();
                    }
                }
            };

            peerConnections[userId] = pc;

            if (isInitiator) {
                pc.createOffer()
                    .then(offer => pc.setLocalDescription(offer))
                    .then(() => {
                        ws.send(JSON.stringify({
                            type: 'offer',
                            to: userId,
                            sdp: pc.localDescription
                        }));
                    })
                    .catch(error => console.error('Error creating offer:', error));
            }

            return pc;
        }

        // --- Screen Sharing Functions ---
        function requestScreenSharePermission() {
            if (myUserId === teacherId) {
                displayStatus('Teachers can always share screen.', 'info');
                return;
            }
            
            ws.send(JSON.stringify({
                type: 'request_screen_share_permission',
                roomId: currentRoomId
            }));
            displayStatus('Requesting screen sharing permission from teacher...', 'info');
        }

        async function startScreenSharing() {
            try {
                // Check if user has permission to share screen
                if (!screenSharePermission && myUserId !== teacherId) {
                    displayStatus('You need permission from the teacher to share your screen.', 'error');
                    return;
                }

                // Check if someone else is already sharing
                if (isScreenSharing && screenShareOwnerId !== myUserId) {
                    displayStatus('Someone else is already sharing their screen.', 'error');
                    return;
                }

                // Get screen stream
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: {
                        cursor: 'always',
                        displaySurface: 'monitor'
                    },
                    audio: false
                });

                // Update UI
                screenShareBtn.classList.add('hidden');
                stopScreenShareBtn.classList.remove('hidden');
                isScreenSharing = true;
                screenShareOwnerId = myUserId;
                screenShareOwnerName = username;

                // Replace local video with screen
                if (localVideo) {
                    localVideo.srcObject = screenStream;
                }
                // Ensure compositor gets continuous screen frames regardless of UI switches
                try { ensureHiddenScreenVideo(screenStream); } catch (_) {}

                // Update all peer connections with screen stream
                Object.keys(peerConnections).forEach(userId => {
                    const pc = peerConnections[userId];
                    if (pc && pc.connectionState === 'connected') {
                        // Remove old video track
                        const senders = pc.getSenders();
                        const videoSender = senders.find(sender => 
                            sender.track && sender.track.kind === 'video'
                        );
                        if (videoSender) {
                            pc.removeTrack(videoSender);
                        }
                        
                        // Add new screen track
                        const screenTrack = screenStream.getVideoTracks()[0];
                        if (screenTrack) {
                            pc.addTrack(screenTrack, screenStream);
                        }
                    }
                });

                // Force renegotiation for all peer connections
                Object.keys(peerConnections).forEach(userId => {
                    const pc = peerConnections[userId];
                    if (pc && pc.connectionState === 'connected') {
                        pc.createOffer()
                            .then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                ws.send(JSON.stringify({
                                    type: 'offer',
                                    to: userId,
                                    sdp: pc.localDescription
                                }));
                            })
                            .catch(error => {
                                console.error('Error creating offer for screen sharing:', error);
                            });
                    }
                });

                // Store screen stream for new peer connections
                window.currentScreenStream = screenStream;

                // Notify other participants
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'screen_share_start',
                        roomId: currentRoomId,
                        userId: myUserId,
                        username: username
                    }));
                }

                // Handle screen share stop
                screenStream.getVideoTracks()[0].onended = () => {
                    stopScreenSharing();
                };

                displayStatus('Screen sharing started successfully!', 'success');
                
            } catch (error) {
                console.error('Error starting screen share:', error);
                if (error.name === 'NotAllowedError') {
                    displayStatus('Screen sharing permission denied.', 'error');
                } else {
                    displayStatus('Failed to start screen sharing: ' + error.message, 'error');
                }
            }
        }

        async function stopScreenSharing() {
            try {
                if (!isScreenSharing || screenShareOwnerId !== myUserId) {
                    return;
                }

                // Stop screen stream
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                    screenStream = null;
                }

                // Clear stored screen stream
                window.currentScreenStream = null;

                // Restore local video
                if (localVideo && localStream) {
                    localVideo.srcObject = localStream;
                }

                // Update all peer connections with original video stream
                Object.keys(peerConnections).forEach(userId => {
                    const pc = peerConnections[userId];
                    if (pc && pc.connectionState === 'connected') {
                        // Remove screen track
                        const senders = pc.getSenders();
                        const videoSender = senders.find(sender => 
                            sender.track && sender.track.kind === 'video'
                        );
                        if (videoSender) {
                            pc.removeTrack(videoSender);
                        }
                        
                        // Add back original video track
                        if (localStream) {
                            const videoTrack = localStream.getVideoTracks()[0];
                            if (videoTrack) {
                                pc.addTrack(videoTrack, localStream);
                            }
                        }
                    }
                });

                // Force renegotiation for all peer connections
                Object.keys(peerConnections).forEach(userId => {
                    const pc = peerConnections[userId];
                    if (pc && pc.connectionState === 'connected') {
                        pc.createOffer()
                            .then(offer => pc.setLocalDescription(offer))
                            .then(() => {
                                ws.send(JSON.stringify({
                                    type: 'offer',
                                    to: userId,
                                    sdp: pc.localDescription
                                }));
                            })
                            .catch(error => {
                                console.error('Error creating offer for stopping screen sharing:', error);
                            });
                    }
                });

                // Update UI
                screenShareBtn.classList.remove('hidden');
                stopScreenShareBtn.classList.add('hidden');
                isScreenSharing = false;
                screenShareOwnerId = null;
                screenShareOwnerName = '';

                // Notify other participants
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'screen_share_stop',
                        roomId: currentRoomId,
                        userId: myUserId,
                        username: username
                    }));
                }

                displayStatus('Screen sharing stopped.', 'info');
                
            } catch (error) {
                console.error('Error stopping screen share:', error);
                displayStatus('Error stopping screen sharing: ' + error.message, 'error');
            }
        }

        function updateScreenShareStatus(ownerId, ownerName, isActive) {
            if (isActive) {
                screenShareStatus.classList.remove('hidden');
                screenShareOwner.textContent = ownerName || 'Unknown';
                screenShareInfo.textContent = `Shared by: ${ownerName || 'Unknown'}`;
            } else {
                screenShareStatus.classList.add('hidden');
                screenShareOwner.textContent = '';
                screenShareInfo.textContent = '';
            }
        }



        // --- Whiteboard Functionality ---
        function drawOnCanvas(x1, y1, x2, y2, color) {
            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = currentLineWidth;
            ctx.lineCap = 'round';
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
        }

        function drawTextOnCanvas(textContent, x, y, color, fontSize, fontFamily, fontWeight, fontStyle, textDecoration) {
            ctx.save();
            ctx.fillStyle = color;
            const finalFontSize = fontSize.endsWith('px') ? fontSize : `${fontSize}px`;
            const fontString = `${fontStyle} ${fontWeight} ${finalFontSize} ${fontFamily}`;
            ctx.font = fontString;
            ctx.textBaseline = 'top';

            const lines = textContent.split('\n');
            let currentY = y;
            const numericFontSize = parseFloat(finalFontSize);
            const lineHeight = numericFontSize * 1.2;

            lines.forEach(line => {
                ctx.fillText(line, x, currentY);
                if (textDecoration === 'underline') {
                    const textWidth = ctx.measureText(line).width;
                    ctx.beginPath();
                    ctx.rect(x, currentY + numericFontSize + 2, textWidth, 1);
                    ctx.fill();
                    ctx.closePath();
                }
                currentY += lineHeight;
            });
            ctx.restore();
        }

        function clearCanvas(isLocal) {
            if (isLocal && myUserId !== teacherId) {
                displayStatus('Only the teacher can clear the whiteboard.', 'error');
                return;
            }

            ctx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
            if (isLocal && ws && ws.readyState === WebSocket.OPEN) {
                whiteboardHistory = [];
                graphFunctions = [];
                ws.send(JSON.stringify({ type: 'clear-whiteboard' }));
            }
            // Only draw coordinate grid if there are graph functions or if grid is explicitly enabled
            if (graphFunctions.length > 0 || showGrid) {
                drawCoordinateGrid();
            }
        }

        // --- Event Listeners ---
        // Video source toggle event listeners
        showTeacherBtn.addEventListener('click', showTeacherVideo);
        showScreenShareBtn.addEventListener('click', showScreenShareVideo);
        
        createRoomBtn.addEventListener('click', () => {
            username = usernameInput.value.trim();
            if (!username) {
                displayStatus('Please enter your name.', 'error');
                return;
            }
            currentRoomId = generateRoomId();
            roomInput.value = currentRoomId;
            displayStatus(`Creating room: ${currentRoomId}...`, 'info');
            initLocalStream();
            initWebSocket(currentRoomId, username);
        });

        joinRoomBtn.addEventListener('click', () => {
            username = usernameInput.value.trim();
            currentRoomId = roomInput.value.trim();
            if (!username || !currentRoomId) {
                displayStatus('Please enter your name and the room ID.', 'error');
                return;
            }
            displayStatus(`Joining room: ${currentRoomId}...`, 'info');
            initLocalStream();
            initWebSocket(currentRoomId, username);
        });

        colorPicker.addEventListener('change', (e) => {
            currentColor = e.target.value;
            if (activeTextArea) {
                activeTextArea.style.color = currentColor;
            }
        });

        clearWhiteboardBtn.addEventListener('click', () => {
            clearCanvas(true);
        });
        
        // Graph plotting event listeners
        plotFunctionBtn.addEventListener('click', () => {
            const functionText = functionInput.value.trim();
            if (functionText) {
                plotFunction(functionText);
            }
        });
        
        clearGraphBtn.addEventListener('click', () => {
            clearGraph();
        });
        
        showGridBtn.addEventListener('click', () => {
            showGrid = !showGrid;
            showGridBtn.textContent = showGrid ? '📐 Hide Grid' : '📐 Show Grid';
            redrawWhiteboardHistory();
        });
        
        autoScaleBtn.addEventListener('click', () => {
            autoScaleGraph();
        });
        
        // Quick function buttons
        document.querySelectorAll('.quick-function-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const functionText = btn.getAttribute('data-function');
                functionInput.value = functionText;
                plotFunction(functionText);
            });
        });

        undoBtn.addEventListener('click', () => {
            if (myUserId === teacherId && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'undo' }));
            } else {
                displayStatus('Only the teacher can undo.', 'error');
            }
        });
        redoBtn.addEventListener('click', () => {
            if (myUserId === teacherId && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'redo' }));
            } else {
                displayStatus('Only the teacher can redo.', 'error');
            }
        });

        toggleMicBtn.addEventListener('click', () => {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    toggleMicBtn.textContent = audioTrack.enabled ? '🎤 Toggle Mic' : '🔇 Mic Off';
                    displayStatus(`Microphone ${audioTrack.enabled ? 'enabled' : 'disabled'}.`, 'info');
                }
            } else {
                displayStatus('No local stream available to toggle microphone.', 'error');
            }
        });
        
        // Screen sharing event listeners
        screenShareBtn.addEventListener('click', startScreenSharing);
        stopScreenShareBtn.addEventListener('click', stopScreenSharing);
        requestScreenShareBtn.addEventListener('click', requestScreenSharePermission);

        toggleCamBtn.addEventListener('click', () => {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    toggleCamBtn.textContent = videoTrack.enabled ? '📹 Toggle Cam' : '📷 Cam Off';
                    displayStatus(`Camera ${videoTrack.enabled ? 'enabled' : 'disabled'}.`, 'info');
                }
            } else {
                displayStatus('No local stream available to toggle camera.', 'error');
            }
        });

        requestWhiteboardAccessBtn.addEventListener('click', () => {
            if (myUserId !== teacherId && ws && ws.readyState === WebSocket.OPEN) {
                displayStatus('Requesting whiteboard access...', 'info');
                ws.send(JSON.stringify({
                    type: 'request-whiteboard-access',
                    targetUserId: myUserId,
                    targetUsername: username
                }));
            } else if (myUserId === teacherId) {
                displayStatus('As the teacher, you always have whiteboard access.', 'info');
            } else {
                displayStatus('Cannot request whiteboard access. Not connected to class.', 'error');
            }
        });

        manageWhiteboardAccessBtn.addEventListener('click', () => {
            if (myUserId === teacherId) {
                whiteboardRequestModal.style.display = 'flex';
            } else {
                displayStatus('You are not authorized to manage whiteboard access.', 'error');
            }
        });

        createQuizBtn.addEventListener('click', () => {
            if (myUserId === teacherId) {
                // Store current room info for quiz creation
                localStorage.setItem('quizRoomId', currentRoomId);
                localStorage.setItem('quizUsername', username);
                localStorage.setItem('userRole', 'teacher');
                window.open('quiz-demo.html', '_blank');
            } else {
                displayStatus('Only teachers can create quizzes.', 'error');
            }
        });

        takeQuizBtn.addEventListener('click', () => {
            if (myUserId !== teacherId) {
                // Store current room info for quiz taking
                localStorage.setItem('quizRoomId', currentRoomId);
                localStorage.setItem('quizUsername', username);
                localStorage.setItem('userRole', 'student');
                window.open('quiz-demo.html', '_blank');
            } else {
                displayStatus('Teachers should use the Create Quiz button.', 'info');
            }
        });

        setSubjectBtn.addEventListener('click', () => {
            if (myUserId !== teacherId) {
                displayStatus('Only the teacher can set the subject.', 'error');
                return;
            }
            const subj = subjectInput.value.trim();
            ws && ws.readyState === WebSocket.OPEN && ws.send(JSON.stringify({ type: 'set-subject', subject: subj, payload: subj }));
        });

        closeButton.addEventListener('click', () => {
            whiteboardRequestModal.style.display = 'none';
        });

        screenShareCloseButton.addEventListener('click', () => {
            screenSharePermissionModal.style.display = 'none';
            pendingScreenShareRequest = null;
        });

        // Screen share permission button handlers
        grantScreenShareBtn.addEventListener('click', () => {
            if (pendingScreenShareRequest && ws && ws.readyState === WebSocket.OPEN) {
                const username = pendingScreenShareRequest.username;
                const messageToSend = {
                    type: 'screen_share_permission_response',
                    roomId: currentRoomId,
                    targetUserId: pendingScreenShareRequest.userId,
                    payload: true
                };
                ws.send(JSON.stringify(messageToSend));
                screenSharePermissionModal.style.display = 'none';
                pendingScreenShareRequest = null;
                displayStatus(`Granted screen sharing permission to ${username}`, 'success');
            }
        });

        denyScreenShareBtn.addEventListener('click', () => {
            if (pendingScreenShareRequest && ws && ws.readyState === WebSocket.OPEN) {
                const username = pendingScreenShareRequest.username;
                const messageToSend = {
                    type: 'screen_share_permission_response',
                    roomId: currentRoomId,
                    targetUserId: pendingScreenShareRequest.userId,
                    payload: false
                };
                ws.send(JSON.stringify(messageToSend));
                screenSharePermissionModal.style.display = 'none';
                pendingScreenShareRequest = null;
                displayStatus(`Denied screen sharing permission to ${username}`, 'info');
            }
        });

        window.addEventListener('click', (event) => {
            if (event.target === whiteboardRequestModal) {
                whiteboardRequestModal.style.display = 'none';
            }
            if (event.target === screenSharePermissionModal) {
                screenSharePermissionModal.style.display = 'none';
            }
        });

        pendingRequestList.addEventListener('click', (e) => {
            const grantBtn = e.target.closest('.grant-btn');
            const denyBtn = e.target.closest('.deny-btn');

            if (grantBtn || denyBtn) {
                const listItem = e.target.closest('li');
                if (!listItem) {
                    console.error('Could not find parent list item for button click.');
                    return;
                }
                const targetUserId = listItem.dataset.userId;
                const targetUsername = listItem.dataset.username;

                // --- NEW DEBUGGING LOG ---
                console.log(`[DEBUG] Clicked button. Checking values from list item. targetUserId: ${targetUserId}, targetUsername: ${targetUsername}`);
                if (!targetUserId || !targetUsername) {
                    console.error('[DEBUG] Invalid user data on list item. targetUserId or targetUsername is missing.');
                    return;
                }


                if (grantBtn) {
                    console.log(`[TEACHER-ACTION] Granting permission to userId: ${targetUserId}`);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'grant-whiteboard-access', targetUserId: targetUserId, targetUsername: targetUsername }));
                        removePendingRequest(targetUserId);
                    }
                } else if (denyBtn) {
                    console.log(`[TEACHER-ACTION] Denying permission to userId: ${targetUserId}`);
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({ type: 'deny-whiteboard-access', targetUserId: targetUserId, targetUsername: targetUsername }));
                        removePendingRequest(targetUserId);
                    }
                }
            }
        });

        grantedPermissionList.addEventListener('click', (e) => {
            const revokeBtn = e.target.closest('.revoke-btn');
            if (revokeBtn) {
                const listItem = e.target.closest('li');
                if (!listItem) {
                    console.error('Could not find parent list item for revoke button click.');
                    return;
                }
                const targetUserId = listItem.dataset.userId;
                const targetUsername = listItem.dataset.username;

                console.log(`[TEACHER-ACTION] Revoking permission from userId: ${targetUserId}`);
                if (!targetUserId || !targetUsername) {
                     console.error('[TEACHER-ACTION] Invalid user data found on list item during revoke.', { targetUserId, targetUsername });
                     return;
                }

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'deny-whiteboard-access', targetUserId: targetUserId, targetUsername: targetUsername }));
                }
            }
        });

        // Event listeners for the new shape buttons
        drawToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'draw';
            updateUIState();
        });
        textToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'text';
            updateUIState();
        });
        lineToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'line';
            isEraserActive = false;
            currentLineWidth = 2;
            updateUIState();
        });
        rectToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'rect';
            isEraserActive = false;
            currentLineWidth = 2;
            updateUIState();
        });
        ellipseToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'ellipse';
            isEraserActive = false;
            currentLineWidth = 2;
            updateUIState();
        });
        triangleToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'triangle';
            isEraserActive = false;
            currentLineWidth = 2;
            updateUIState();
        });
        graphToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'graph';
            isEraserActive = false;
            currentLineWidth = 2;
            updateUIState();
            graphInterface.classList.toggle('hidden');
        });
        
        // File sharing tool button
        const fileSharingToolBtn = document.getElementById('fileSharingToolBtn');
        fileSharingToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'files';
            isEraserActive = false;
            currentLineWidth = 2;
            updateUIState();
            fileSharingInterface.classList.toggle('hidden');
        });
        eraserToolBtn.addEventListener('click', () => {
            if (activeTextArea) finalizeTextInput(true);
            currentTool = 'draw';
            isEraserActive = true;
            currentLineWidth = 14;
            updateUIState();
        });

        fontSizeSelect.addEventListener('change', (e) => {
            currentFontSize = e.target.value;
            if (activeTextArea) {
                activeTextArea.style.fontSize = currentFontSize;
            }
        });

        fontFamilySelect.addEventListener('change', (e) => {
            currentFontFamily = e.target.value;
            if (activeTextArea) {
                activeTextArea.style.fontFamily = currentFontFamily;
            }
        });

        boldBtn.addEventListener('click', () => {
            isBold = !isBold;
            boldBtn.classList.toggle('bg-blue-300', isBold);
            boldBtn.classList.toggle('text-blue-900', isBold);
            boldBtn.classList.toggle('bg-gray-200', !isBold);
            boldBtn.classList.toggle('text-gray-800', !isBold);
            if (activeTextArea) {
                activeTextArea.style.fontWeight = isBold ? 'bold' : 'normal';
            }
        });

        italicBtn.addEventListener('click', () => {
            isItalic = !isItalic;
            italicBtn.classList.toggle('bg-blue-300', isItalic);
            italicBtn.classList.toggle('text-blue-900', isItalic);
            italicBtn.classList.toggle('bg-gray-200', !isItalic);
            italicBtn.classList.toggle('text-gray-800', !isItalic);
            if (activeTextArea) {
                activeTextArea.style.fontStyle = isItalic ? 'italic' : 'normal';
            }
        });

        underlineBtn.addEventListener('click', () => {
            isUnderline = !isUnderline;
            underlineBtn.classList.toggle('bg-blue-300', isUnderline);
            underlineBtn.classList.toggle('text-blue-900', isUnderline);
            underlineBtn.classList.toggle('bg-gray-200', !isUnderline);
            underlineBtn.classList.toggle('text-gray-800', !isUnderline);
            if (activeTextArea) {
                activeTextArea.style.textDecoration = isUnderline ? 'underline' : 'none';
            }
        });


        function createTextInput(x, y) {
            if (activeTextArea) {
                finalizeTextInput(true);
            }

            activeTextArea = document.createElement('textarea');
            activeTextArea.className = 'whiteboard-text-input';
            activeTextArea.style.left = `${x}px`;
            activeTextArea.style.top = `${y}px`;
            activeTextArea.style.color = currentColor;
            activeTextArea.style.fontSize = currentFontSize;
            activeTextArea.style.fontFamily = currentFontFamily;
            activeTextArea.style.fontWeight = isBold ? 'bold' : 'normal';
            activeTextArea.style.fontStyle = isItalic ? 'italic' : 'normal';
            activeTextArea.style.textDecoration = isUnderline ? 'underline' : 'none';
            activeTextArea.placeholder = 'Type here...';
            activeTextArea.rows = 1;
            activeTextArea.style.width = 'auto';
            activeTextArea.style.minWidth = '50px';
            activeTextArea.style.height = 'auto';

            whiteboardContainer.appendChild(activeTextArea);
            activeTextArea.focus();

            activeTextArea.addEventListener('input', () => {
                console.log(`[TYPING] Text input event triggered`);
                console.log(`[TYPING] myUserId: ${myUserId}, teacherId: ${teacherId}`);
                
                activeTextArea.style.height = 'auto';
                activeTextArea.style.height = `${activeTextArea.scrollHeight}px`;
                const maxTextWidth = whiteboardCanvas.width - activeTextArea.offsetLeft - 10;
                activeTextArea.style.width = `${Math.min(activeTextArea.scrollWidth, maxTextWidth)}px`;
                
                // Send typing status on each input (with debouncing)
                if (myUserId === teacherId) {
                    console.log(`[TYPING] Teacher typing detected, sending status`);
                    // Clear existing timer
                    if (typingTimer) {
                        clearTimeout(typingTimer);
                    }
                    // Send typing status
                    sendTypingStatus(true);
                    // Set timer to stop typing status after 1 second of no input
                    typingTimer = setTimeout(() => {
                        console.log(`[TYPING] Typing timeout, sending stop status`);
                        sendTypingStatus(false);
                    }, 1000);
                } else {
                    console.log(`[TYPING] Not a teacher, not sending typing status`);
                }
            });

            activeTextArea.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault();
                    finalizeTextInput(true);
                }
            });
        }

        function finalizeTextInput(isLocal) {
            if (!activeTextArea || !whiteboardContainer.contains(activeTextArea)) {
                return;
            }

            const text = activeTextArea.value.trim();
            const x = activeTextArea.offsetLeft;
            const y = activeTextArea.offsetTop;

            if (text) {
                drawTextOnCanvas(
                    text,
                    x,
                    y,
                    currentColor,
                    currentFontSize,
                    currentFontFamily,
                    isBold ? 'bold' : 'normal',
                    isItalic ? 'italic' : 'normal',
                    isUnderline ? 'underline' : 'none'
                );

                if (isLocal && ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'text',
                        textContent: text,
                        textX: x,
                        textY: y,
                        color: currentColor,
                        fontSize: currentFontSize,
                        fontFamily: currentFontFamily,
                        fontWeight: isBold ? 'bold' : 'normal',
                        fontStyle: isItalic ? 'italic' : 'normal',
                        textDecoration: isUnderline ? 'underline' : 'none'
                    }));
                    whiteboardHistory.push({
                        type: 'text',
                        textContent: text,
                        textX: x,
                        textY: y,
                        color: currentColor,
                        fontSize: currentFontSize,
                        fontFamily: currentFontFamily,
                        fontWeight: isBold ? 'bold' : 'normal',
                        fontStyle: isItalic ? 'italic' : 'normal',
                        textDecoration: isUnderline ? 'underline' : 'none'
                    });
                }
            }

            activeTextArea.remove();
            activeTextArea = null;
        }

        whiteboardCanvas.addEventListener('mousedown', handleInteractionStart);
        whiteboardCanvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleInteractionStart(e.touches[0]);
        });

        function handleInteractionStart(e) {
            if (!hasActiveWhiteboardPermission()) {
                displayStatus('whiteboardCanvas: No permission for whiteboard action.', 'error');
                return;
            }

            if (activeTextArea && !activeTextArea.contains(e.target)) {
                finalizeTextInput(true);
            }

            const rect = whiteboardCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (currentTool === 'draw') {
                isDrawing = true;
                [lastX, lastY] = [x, y];
            } else if (currentTool === 'text') {
                createTextInput(x, y);
            } else { // Shape tool is active
                isDrawingShape = true;
                [startX, startY] = [x, y];
            }
        }

        document.addEventListener('mousedown', (e) => {
            if (activeTextArea && !whiteboardContainer.contains(e.target)) {
                finalizeTextInput(true);
            }
        });


        whiteboardCanvas.addEventListener('mousemove', handleDrawMove);
        whiteboardCanvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            handleDrawMove(e.touches[0]);
        });

        function handleDrawMove(e) {
            if (!hasActiveWhiteboardPermission()) {
                isDrawing = false;
                isDrawingShape = false;
                return;
            }

            const rect = whiteboardCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            if (currentTool === 'draw' && isDrawing) {
                const colorToUse = isEraserActive ? '#ffffff' : currentColor;
                
                drawLineOnCanvas(lastX, lastY, x, y, colorToUse);
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'draw',
                        x1: lastX,
                        y1: lastY,
                        x2: x,
                        y2: y,
                        color: colorToUse,
                        lineWidth: currentLineWidth
                    }));
                }
                whiteboardHistory.push({
                    type: 'draw',
                    x1: lastX,
                    y1: lastY,
                    x2: x,
                    y2: y,
                    color: colorToUse,
                    lineWidth: currentLineWidth
                });

                [lastX, lastY] = [x, y];
            } else if (currentTool !== 'draw' && currentTool !== 'text' && isDrawingShape) {
                // Clear the canvas, redraw history, and then draw a temporary shape
                ctx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);
                redrawWhiteboardHistory();
                switch (currentTool) {
                    case 'line':
                        drawLineOnCanvas(startX, startY, x, y, currentColor);
                        break;
                    case 'rect':
                        drawRectOnCanvas(startX, startY, x, y, currentColor);
                        break;
                    case 'ellipse':
                        drawEllipseOnCanvas(startX, startY, x, y, currentColor);
                        break;
                    case 'triangle':
                        drawTriangleOnCanvas(startX, startY, x, y, currentColor);
                        break;
                }
            }
        }

        whiteboardCanvas.addEventListener('mouseup', (e) => handleInteractionEnd(e));
        whiteboardCanvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            handleInteractionEnd(e.changedTouches[0]);
        });
        whiteboardCanvas.addEventListener('mouseout', (e) => handleInteractionEnd(e));

        function handleInteractionEnd(e) {
            if (!hasActiveWhiteboardPermission()) {
                isDrawing = false;
                isDrawingShape = false;
                return;
            }

            if (currentTool === 'draw') {
                isDrawing = false;
            } else if (currentTool !== 'text' && isDrawingShape) { // A shape has been drawn
                isDrawingShape = false;
                
                // Get coordinates from the event (handle both mouse and touch events)
                const clientX = e.clientX || (e.touches && e.touches[0].clientX) || e.changedTouches[0].clientX;
                const clientY = e.clientY || (e.touches && e.touches[0].clientY) || e.changedTouches[0].clientY;
                
                const rect = whiteboardCanvas.getBoundingClientRect();
                const x = clientX - rect.left;
                const y = clientY - rect.top;

                // Finalize the drawing and add to history
                let shapeData = {
                    type: 'shape',
                    shape: currentTool,
                    x1: startX,
                    y1: startY,
                    x2: x,
                    y2: y,
                    color: currentColor
                };

                // Redraw the shape permanently
                switch (currentTool) {
                    case 'line':
                        drawLineOnCanvas(startX, startY, x, y, currentColor);
                        break;
                    case 'rect':
                        drawRectOnCanvas(startX, startY, x, y, currentColor);
                        break;
                    case 'ellipse':
                        drawEllipseOnCanvas(startX, startY, x, y, currentColor);
                        break;
                    case 'triangle':
                        drawTriangleOnCanvas(startX, startY, x, y, currentColor);
                        break;
                }

                whiteboardHistory.push(shapeData);
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify(shapeData));
                }
            }
        }

        // Typing indicator functions
        function showTeacherTyping(teacherUsername) {
            console.log(`[TYPING] showTeacherTyping called with: ${teacherUsername}`);
            console.log(`[TYPING] myUserId: ${myUserId}, teacherId: ${teacherId}`);
            
            if (myUserId === teacherId) {
                console.log(`[TYPING] Teacher themselves, not showing indicator`);
                return; // Don't show for teacher themselves
            }
            
            console.log(`[TYPING] Showing typing indicator for student`);
            typingTeacherName.textContent = teacherUsername;
            typingIndicator.classList.remove('hidden');
            
            // Clear existing timer
            if (teacherTypingTimer) {
                clearTimeout(teacherTypingTimer);
            }
            
            // Hide typing indicator after 3 seconds of no typing
            teacherTypingTimer = setTimeout(() => {
                hideTeacherTyping();
            }, 3000);
        }
        
        function hideTeacherTyping() {
            typingIndicator.classList.add('hidden');
            if (teacherTypingTimer) {
                clearTimeout(teacherTypingTimer);
                teacherTypingTimer = null;
            }
        }
        
        function sendTypingStatus(isTyping) {
            console.log(`[TYPING] sendTypingStatus called with isTyping: ${isTyping}`);
            console.log(`[TYPING] ws: ${ws}, readyState: ${ws?.readyState}, myUserId: ${myUserId}, teacherId: ${teacherId}`);
            
            if (ws && ws.readyState === WebSocket.OPEN && myUserId === teacherId) {
                const typingMessage = {
                    type: 'typing-status',
                    isTyping: isTyping,
                    username: username
                };
                console.log(`[TYPING] Sending typing status:`, typingMessage);
                ws.send(JSON.stringify(typingMessage));
            } else {
                console.log(`[TYPING] Not sending typing status - conditions not met`);
            }
        }

        // File upload event listeners
        fileUploadArea.addEventListener('click', () => {
            fileInput.click();
        });
        
        fileUploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            fileUploadArea.classList.add('border-blue-500', 'bg-blue-50');
        });
        
        fileUploadArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('border-blue-500', 'bg-blue-50');
        });
        
        fileUploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            fileUploadArea.classList.remove('border-blue-500', 'bg-blue-50');
            
            const files = Array.from(e.dataTransfer.files);
            files.forEach(file => {
                uploadFile(file);
            });
        });
        
        fileInput.addEventListener('change', (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                uploadFile(file);
            });
            e.target.value = ''; // Reset input
        });
        
        // File download and delete event listeners
        sharedFilesList.addEventListener('click', (e) => {
            const downloadBtn = e.target.closest('.download-btn');
            const deleteBtn = e.target.closest('.delete-btn');
            
            if (downloadBtn) {
                const fileItem = downloadBtn.closest('[data-file-id]');
                const fileId = fileItem.dataset.fileId;
                const file = sharedFiles.find(f => f.id === fileId);
                
                if (file) {
                    const fileExtension = file.name.split('.').pop();
                    const downloadUrl = `/files/${currentRoomId}/${fileId}.${fileExtension}`;
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = file.name;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }
            } else if (deleteBtn) {
                const fileItem = deleteBtn.closest('[data-file-id]');
                const fileId = fileItem.dataset.fileId;
                
                if (confirm('Are you sure you want to delete this file?')) {
                    if (ws && ws.readyState === WebSocket.OPEN) {
                        ws.send(JSON.stringify({
                            type: 'delete-file',
                            fileId: fileId
                        }));
                    }
                }
            }
        });

        // --- Recording Functions ---
        
        // Canvas for compositing multiple video sources
        let compositeCanvas = null;
        let compositeCtx = null;
        let compositeStream = null;
        
        function createCompositeCanvas() {
            if (!compositeCanvas) {
                compositeCanvas = document.createElement('canvas');
                compositeCanvas.width = 1280;
                compositeCanvas.height = 720;
                compositeCtx = compositeCanvas.getContext('2d');
            }
            return compositeCanvas;
        }
        
        function isVideoReady(videoEl) {
            return !!(videoEl && videoEl.videoWidth > 0 && videoEl.videoHeight > 0);
        }
        
        function ensureHiddenCameraVideo() {
            if (!hiddenCameraVideo) {
                hiddenCameraVideo = document.createElement('video');
                hiddenCameraVideo.autoplay = true;
                hiddenCameraVideo.muted = true;
                hiddenCameraVideo.playsInline = true;
                hiddenCameraVideo.setAttribute('playsinline', '');
                hiddenCameraVideo.style.position = 'absolute';
                hiddenCameraVideo.style.left = '-9999px';
                hiddenCameraVideo.style.top = '-9999px';
                hiddenCameraVideo.style.width = '1px';
                hiddenCameraVideo.style.height = '1px';
                document.body.appendChild(hiddenCameraVideo);
            }
            if (localStream && hiddenCameraVideo.srcObject !== localStream) {
                hiddenCameraVideo.srcObject = localStream;
                hiddenCameraVideo.play().catch(() => {});
            }
        }
        
        function ensureHiddenScreenVideo(stream) {
            if (!hiddenScreenVideo) {
                hiddenScreenVideo = document.createElement('video');
                hiddenScreenVideo.autoplay = true;
                hiddenScreenVideo.muted = true;
                hiddenScreenVideo.playsInline = true;
                hiddenScreenVideo.setAttribute('playsinline', '');
                hiddenScreenVideo.style.position = 'absolute';
                hiddenScreenVideo.style.left = '-9999px';
                hiddenScreenVideo.style.top = '-9999px';
                hiddenScreenVideo.style.width = '1px';
                hiddenScreenVideo.style.height = '1px';
                document.body.appendChild(hiddenScreenVideo);
            }
            if (stream && hiddenScreenVideo.srcObject !== stream) {
                hiddenScreenVideo.srcObject = stream;
                hiddenScreenVideo.play().catch(() => {});
            }
        }
        
        function checkVideoReadiness() {
            const status = {
                hasLocalStream: !!localStream,
                hasLocalVideo: !!localVideo,
                videoWidth: localVideo ? localVideo.videoWidth : 0,
                videoHeight: localVideo ? localVideo.videoHeight : 0,
                videoReady: !!(localVideo && localVideo.videoWidth > 0 && localVideo.videoHeight > 0),
                streamActive: localStream ? localStream.active : false,
                videoTracks: localStream ? localStream.getVideoTracks().length : 0,
                audioTracks: localStream ? localStream.getAudioTracks().length : 0,
                mediaRecorderSupported: typeof MediaRecorder !== 'undefined',
                webmSupported: MediaRecorder && MediaRecorder.isTypeSupported('video/webm;codecs=vp9'),
                vp8Supported: MediaRecorder && MediaRecorder.isTypeSupported('video/webm;codecs=vp8')
            };
            console.log('Video readiness check:', status);
            return status;
        }
        
        function drawCompositeFrame() {
            if (!compositeCtx) return;
            
            // Clear canvas
            compositeCtx.fillStyle = '#ffffff';
            compositeCtx.fillRect(0, 0, compositeCanvas.width, compositeCanvas.height);
            
            // Debug logging (only log occasionally to avoid spam)
            if (Math.random() < 0.01) { // Log ~1% of frames
                console.log('Drawing composite frame:', {
                    hasWhiteboard: !!whiteboardCanvas,
                    hasLocalVideo: !!(localVideo && localVideo.videoWidth > 0),
                    hasLocalStream: !!localStream,
                    isScreenSharing: isScreenSharing,
                    hasScreenStream: !!(screenStream && screenStream.active),
                    videoWidth: localVideo ? localVideo.videoWidth : 0,
                    videoHeight: localVideo ? localVideo.videoHeight : 0,
                    canvasWidth: compositeCanvas.width,
                    canvasHeight: compositeCanvas.height
                });
            }
            
            const canvasWidth = compositeCanvas.width;
            const canvasHeight = compositeCanvas.height;
            
            // Base layer: screen share if active; otherwise whiteboard; otherwise neutral background
            if (screenStream && isScreenSharing && hiddenScreenVideo && hiddenScreenVideo.videoWidth > 0 && hiddenScreenVideo.videoHeight > 0) {
                compositeCtx.drawImage(hiddenScreenVideo, 0, 0, canvasWidth, canvasHeight);
                // Screen share indicator
                compositeCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                compositeCtx.fillRect(10, 10, 200, 30);
                compositeCtx.fillStyle = '#ffffff';
                compositeCtx.font = '14px Arial';
                compositeCtx.fillText('Screen Sharing Active', 20, 30);
            } else if (whiteboardCanvas) {
                compositeCtx.drawImage(whiteboardCanvas, 0, 0, canvasWidth, canvasHeight);
            } else {
                compositeCtx.fillStyle = '#ffffff';
                compositeCtx.fillRect(0, 0, canvasWidth, canvasHeight);
            }
            
            // Draw camera feed as picture-in-picture from hidden camera element
            if (hiddenCameraVideo && hiddenCameraVideo.videoWidth > 0 && hiddenCameraVideo.videoHeight > 0) {
                const pipWidth = 240;
                const pipHeight = 180;
                const pipX = canvasWidth - pipWidth - 20;
                const pipY = 20;
                
                // Draw video with rounded corners
                compositeCtx.save();
                compositeCtx.beginPath();
                // Use arcTo for rounded corners (more compatible)
                const radius = 10;
                compositeCtx.moveTo(pipX + radius, pipY);
                compositeCtx.lineTo(pipX + pipWidth - radius, pipY);
                compositeCtx.quadraticCurveTo(pipX + pipWidth, pipY, pipX + pipWidth, pipY + radius);
                compositeCtx.lineTo(pipX + pipWidth, pipY + pipHeight - radius);
                compositeCtx.quadraticCurveTo(pipX + pipWidth, pipY + pipHeight, pipX + pipWidth - radius, pipY + pipHeight);
                compositeCtx.lineTo(pipX + radius, pipY + pipHeight);
                compositeCtx.quadraticCurveTo(pipX, pipY + pipHeight, pipX, pipY + pipHeight - radius);
                compositeCtx.lineTo(pipX, pipY + radius);
                compositeCtx.quadraticCurveTo(pipX, pipY, pipX + radius, pipY);
                compositeCtx.closePath();
                compositeCtx.clip();
                // Maintain aspect ratio from hidden camera video
                const videoAspectRatio = hiddenCameraVideo.videoWidth / hiddenCameraVideo.videoHeight;
                const pipAspectRatio = pipWidth / pipHeight;
                let drawWidth = pipWidth;
                let drawHeight = pipHeight;
                let drawX = pipX;
                let drawY = pipY;
                if (videoAspectRatio > pipAspectRatio) {
                    drawHeight = pipHeight;
                    drawWidth = pipHeight * videoAspectRatio;
                    drawX = pipX + (pipWidth - drawWidth) / 2;
                } else {
                    drawWidth = pipWidth;
                    drawHeight = pipWidth / videoAspectRatio;
                    drawY = pipY + (pipHeight - drawHeight) / 2;
                }
                compositeCtx.drawImage(hiddenCameraVideo, drawX, drawY, drawWidth, drawHeight);
                compositeCtx.restore();
                
                // Add border
                compositeCtx.strokeStyle = '#ffffff';
                compositeCtx.lineWidth = 3;
                compositeCtx.strokeRect(pipX, pipY, pipWidth, pipHeight);
            }

        }
        
        async function startRecording() {
            if (isRecording) {
                displayStatus('Recording is already active', 'error');
                return;
            }

            try {
                const shouldRecordVideo = recordVideo.checked;
                const shouldRecordAudio = recordAudio.checked;
                const shouldRecordScreen = recordScreen.checked;
                const shouldRecordWhiteboard = recordWhiteboard.checked;

                if (!shouldRecordVideo && !shouldRecordAudio && !shouldRecordScreen && !shouldRecordWhiteboard) {
                    displayStatus('Please select at least one recording option', 'error');
                    return;
                }

                const tracks = [];
                
                // Get audio track from the existing local stream
                if (shouldRecordAudio && localStream && localStream.getAudioTracks().length > 0) {
                    tracks.push(localStream.getAudioTracks()[0]);
                }

                // Create composite video stream
                let videoSourceStream = null;
                
                if (shouldRecordWhiteboard || shouldRecordVideo || shouldRecordScreen) {
                    // Ensure video element is connected to stream
                    if (shouldRecordVideo && localStream && localVideo) {
                        localVideo.srcObject = localStream;
                        
                        // Wait for video to be ready (with timeout)
                        await new Promise((resolve) => {
                            let attempts = 0;
                            const maxAttempts = 40; // 2 seconds max
                            
                            const checkReady = () => {
                                attempts++;
                                if (localVideo.videoWidth > 0 && localVideo.videoHeight > 0) {
                                    console.log('Video element ready:', localVideo.videoWidth, 'x', localVideo.videoHeight);
                                    resolve();
                                } else if (attempts >= maxAttempts) {
                                    console.warn('Video element not ready after timeout');
                                    resolve();
                                } else {
                                    setTimeout(checkReady, 50);
                                }
                            };
                            checkReady();
                        });
                        
                        // Check video readiness
                        const videoStatus = checkVideoReadiness();
                        if (!videoStatus.videoReady) {
                            console.warn('Video not ready after setup, will use fallback recording');
                        }
                    }
                    
                    // Create composite canvas
                    const canvas = createCompositeCanvas();
                    
                    // Set up drawing loop for composite frame
                    const drawInterval = setInterval(() => {
                        if (isRecording) {
                            drawCompositeFrame();
                        } else {
                            clearInterval(drawInterval);
                        }
                    }, 33); // ~30 FPS
                    
                    // Capture stream from composite canvas
                    videoSourceStream = canvas.captureStream(30);
                    
                    // Verify the stream was created successfully
                    if (videoSourceStream && videoSourceStream.getVideoTracks().length > 0) {
                        console.log('Composite canvas stream created successfully with', videoSourceStream.getVideoTracks().length, 'video tracks');
                    } else {
                        console.error('Failed to create composite canvas stream');
                    }
                    
                    // Store interval reference for cleanup
                    canvas.drawInterval = drawInterval;
                }

                if (videoSourceStream && videoSourceStream.getVideoTracks().length > 0) {
                    tracks.push(videoSourceStream.getVideoTracks()[0]);
                } else if (shouldRecordVideo && localStream && localStream.getVideoTracks().length > 0) {
                    // Fallback: use original video stream if composite fails
                    console.log('Using fallback video recording (original stream)');
                    tracks.push(localStream.getVideoTracks()[0]);
                } else if (shouldRecordWhiteboard && whiteboardCanvas) {
                    // Fallback: use whiteboard stream if video fails
                    console.log('Using fallback whiteboard recording');
                    const whiteboardStream = whiteboardCanvas.captureStream(30);
                    if (whiteboardStream.getVideoTracks().length > 0) {
                        tracks.push(whiteboardStream.getVideoTracks()[0]);
                    }
                }

                if (tracks.length === 0) {
                    displayStatus('No valid media tracks found to record.', 'error');
                    return;
                }

                recordingStream = new MediaStream(tracks);

                let mimeType = 'video/webm;codecs=vp9';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm;codecs=vp8';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'video/webm';
                }

                mediaRecorder = new MediaRecorder(recordingStream, { mimeType });

                recordedChunks = [];
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = async () => {
                    const blob = new Blob(recordedChunks, { type: mimeType });
                    console.log('Recording stopped, blob size:', blob.size, 'type:', mimeType);
                    
                    // Store recording ID before it gets cleared by WebSocket message
                    const recordingIdToUpload = currentRecordingId;
                    
                    if (recordingIdToUpload && currentRoomId && blob.size > 0) {
                        // Determine recording type based on what was actually recorded
                        let recordingType = 'composite'; // Default for multi-source recordings
                        
                        if (shouldRecordAudio && !shouldRecordVideo && !shouldRecordScreen && !shouldRecordWhiteboard) {
                            recordingType = 'audio';
                        } else if (shouldRecordScreen && !shouldRecordVideo && !shouldRecordWhiteboard) {
                            recordingType = 'screen';
                        } else if (shouldRecordWhiteboard && !shouldRecordVideo && !shouldRecordAudio && !shouldRecordScreen) {
                            recordingType = 'whiteboard';
                        } else if (shouldRecordVideo && !shouldRecordWhiteboard && !shouldRecordScreen) {
                            recordingType = 'video';
                        }
                        
                        console.log('Uploading recording with type:', recordingType, 'size:', blob.size, 'recordingId:', recordingIdToUpload);
                        try {
                            await uploadRecordingFile(blob, recordingType, recordingIdToUpload, currentRoomId);
                            console.log('Recording upload completed successfully');
                        } catch (error) {
                            console.error('Recording upload failed:', error);
                        }
                    } else {
                        console.warn('Cannot upload recording:', {
                            hasRecordingId: !!recordingIdToUpload,
                            hasRoomId: !!currentRoomId,
                            blobSize: blob.size
                        });
                    }
                    
                    // Clear recording ID after upload attempt (successful or failed)
                    console.log('Clearing currentRecordingId after upload attempt');
                    currentRecordingId = null;
                    
                                    // Clean up composite canvas drawing interval
                    if (compositeCanvas && compositeCanvas.drawInterval) {
                        clearInterval(compositeCanvas.drawInterval);
                        compositeCanvas.drawInterval = null;
                    }
                    
                    // Reset composite canvas
                    compositeCanvas = null;
                    compositeCtx = null;
                };

                mediaRecorder.start();

                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: 'start-recording' }));
                }

                isRecording = true;
                recordingStartTime = Date.now();
                updateRecordingUI(true);
                
                // Log recording configuration for debugging
                console.log('Recording started with configuration:', {
                    video: shouldRecordVideo,
                    audio: shouldRecordAudio,
                    whiteboard: shouldRecordWhiteboard,
                    screen: shouldRecordScreen,
                    hasLocalStream: !!localStream,
                    hasScreenStream: !!screenStream,
                    isScreenSharing: isScreenSharing,
                    videoTracks: localStream ? localStream.getVideoTracks().length : 0,
                    audioTracks: localStream ? localStream.getAudioTracks().length : 0,
                    finalTracks: tracks.length,
                    hasCompositeStream: !!videoSourceStream
                });
                
                displayStatus('Recording started successfully', 'success');

            } catch (error) {
                console.error('Error starting recording:', error);
                displayStatus('Failed to start recording: ' + error.message, 'error');
            }
        }

        function stopRecording() {
            if (!isRecording) {
                displayStatus('No active recording to stop', 'error');
                return;
            }

            try {
                // Stop media recording
                if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                    mediaRecorder.stop();
                }

                // Stop screen recording if active
                if (screenMediaRecorder && screenMediaRecorder.state !== 'inactive') {
                    screenMediaRecorder.stop();
                }

                // Stop all tracks
                if (recordingStream) {
                    recordingStream.getTracks().forEach(track => track.stop());
                    recordingStream = null;
                }

                if (screenRecordingStream) {
                    screenRecordingStream.getTracks().forEach(track => track.stop());
                    screenRecordingStream = null;
                }

                // Send stop recording message to server
                if (ws && ws.readyState === WebSocket.OPEN) {
                    console.log('Sending stop-recording message with ID:', currentRecordingId);
                    ws.send(JSON.stringify({
                        type: 'stop-recording',
                        recordingId: currentRecordingId
                    }));
                }

                isRecording = false;
                recordingStartTime = null;
                updateRecordingUI(false);
                displayStatus('Recording stopped successfully', 'success');
                
                // Note: currentRecordingId will be cleared after upload completes in mediaRecorder.onstop

            } catch (error) {
                console.error('Error stopping recording:', error);
                displayStatus('Failed to stop recording: ' + error.message, 'error');
            }
        }

        function updateRecordingUI(recording) {
            if (recording) {
                startRecordingBtn.classList.add('hidden');
                stopRecordingBtn.classList.remove('hidden');
                recordingIndicator.classList.remove('hidden');
                recordingStatusText.textContent = 'Recording...';
                recordingStatus.classList.add('text-red-600');
            } else {
                startRecordingBtn.classList.remove('hidden');
                stopRecordingBtn.classList.add('hidden');
                recordingIndicator.classList.add('hidden');
                recordingStatusText.textContent = 'Ready to record';
                recordingStatus.classList.remove('text-red-600');
            }
        }

        // --- Playback Functions ---

        async function loadRecordings() {
            if (!currentRoomId) {
                displayStatus('Please join a room first', 'error');
                return;
            }

            try {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'get-recordings'
                    }));
                }
            } catch (error) {
                console.error('Error loading recordings:', error);
                displayStatus('Failed to load recordings: ' + error.message, 'error');
            }
        }

        function playRecording(recording) {
            if (!recording) {
                displayStatus('No recording selected', 'error');
                return;
            }

            currentPlaybackRecording = recording;
            playbackIndex = 0;
            isPlaying = true;

            // Clear canvas for whiteboard playback
            ctx.clearRect(0, 0, whiteboardCanvas.width, whiteboardCanvas.height);

            // Check for video/audio URLs in the recording
            const hasVideo = recording.videoUrl || recording.mediaFiles?.video;
            const hasAudio = recording.audioUrl || recording.mediaFiles?.audio;
            
            // Play video/audio if available
            if (hasVideo) {
                const videoUrl = recording.videoUrl || `/recording/${recording.id}/video`;
                playMediaRecording(videoUrl, 'video');
            } else if (hasAudio) {
                const audioUrl = recording.audioUrl || `/recording/${recording.id}/audio`;
                playMediaRecording(audioUrl, 'audio');
            } else {
                // Show message that only whiteboard is available
                if (localVideo) {
                    localVideo.style.display = 'none';
                }
                displayStatus('This recording only contains whiteboard content', 'info');
            }

            // Start whiteboard playback if there's whiteboard data
            if (recording.whiteboardData && recording.whiteboardData.length > 0) {
                playbackInterval = setInterval(() => {
                    if (playbackIndex >= recording.whiteboardData.length) {
                        stopPlayback();
                        return;
                    }

                    const action = recording.whiteboardData[playbackIndex];
                    replayWhiteboardAction(action);
                    playbackIndex++;

                    // Update progress
                    const progress = (playbackIndex / recording.whiteboardData.length) * 100;
                    playbackProgressBar.style.width = progress + '%';
                    playbackStatus.textContent = `Playing: ${playbackIndex}/${recording.whiteboardData.length} actions`;
                }, 1000 / playbackSpeed);
            }

            updatePlaybackUI(true);
        }

        function playMediaRecording(url, type) {
            if (type === 'video') {
                // For video playback, use the main video container
                if (localVideo) {
                    localVideo.src = url;
                    localVideo.srcObject = null; // Clear any existing stream
                    localVideo.controls = true;
                    localVideo.load();
                    localVideo.play().catch(error => {
                        console.error('Error playing video:', error);
                        displayStatus('Error playing video: ' + error.message, 'error');
                    });
                    
                    // Update label to show it's a recording
                    const localVideoLabel = document.getElementById('localVideoLabel');
                    if (localVideoLabel) {
                        localVideoLabel.textContent = 'Recording Playback';
                    }
                }
            } else {
                // For audio, create separate audio element
                let mediaElement = document.getElementById(`${type}Player`);
                if (!mediaElement) {
                    mediaElement = document.createElement('audio');
                    mediaElement.id = `${type}Player`;
                    mediaElement.controls = true;
                    mediaElement.style.width = '100%';
                    mediaElement.style.margin = '10px 0';
                    
                    const playbackContainer = document.getElementById('playbackInterface');
                    if (playbackContainer) {
                        playbackContainer.appendChild(mediaElement);
                    }
                }
                
                mediaElement.src = url;
                mediaElement.load();
                mediaElement.play().catch(error => {
                    console.error('Error playing audio:', error);
                    displayStatus('Error playing audio: ' + error.message, 'error');
                });
            }
        }

        function cleanupMediaPlayers() {
            // Reset main video element
            if (localVideo) {
                localVideo.pause();
                localVideo.src = '';
                localVideo.controls = false;
                localVideo.style.display = '';
                if (localStream) {
                    localVideo.srcObject = localStream;
                }
                
                const localVideoLabel = document.getElementById('localVideoLabel');
                if (localVideoLabel) {
                    if (myUserId === teacherId) {
                        localVideoLabel.textContent = 'You';
                    } else {
                        const teacherName = (remoteUsernames && remoteUsernames[teacherId]) ? remoteUsernames[teacherId] : 'Teacher';
                        localVideoLabel.textContent = teacherName;
                    }
                }
            }
            
            // Remove audio players
            const audioPlayer = document.getElementById('audioPlayer');
            if (audioPlayer) audioPlayer.remove();
        }

        function pausePlayback() {
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
            
            // Pause media players
            const videoPlayer = document.getElementById('videoPlayer');
            const audioPlayer = document.getElementById('audioPlayer');
            
            if (videoPlayer) videoPlayer.pause();
            if (audioPlayer) audioPlayer.pause();
            
            isPlaying = false;
            updatePlaybackUI(false);
        }

        function stopPlayback() {
            if (playbackInterval) {
                clearInterval(playbackInterval);
                playbackInterval = null;
            }
            
            // Stop and reset media players
            const videoPlayer = document.getElementById('videoPlayer');
            const audioPlayer = document.getElementById('audioPlayer');
            
            if (videoPlayer) {
                videoPlayer.pause();
                videoPlayer.currentTime = 0;
            }
            if (audioPlayer) {
                audioPlayer.pause();
                audioPlayer.currentTime = 0;
            }
            
            isPlaying = false;
            currentPlaybackRecording = null;
            playbackIndex = 0;
            
            // Redraw current whiteboard state
            redrawWhiteboardHistory();
            
            updatePlaybackUI(false);
            playbackProgressBar.style.width = '0%';
            playbackStatus.textContent = '';
        }

        function replayWhiteboardAction(action) {
            switch (action.type) {
                case 'draw':
                    drawLineOnCanvas(action.x1, action.y1, action.x2, action.y2, action.color);
                    break;
                case 'text':
                    drawTextOnCanvas(
                        action.textContent,
                        action.textX,
                        action.textY,
                        action.color,
                        action.fontSize,
                        action.fontFamily,
                        action.fontWeight,
                        action.fontStyle,
                        action.textDecoration
                    );
                    break;
                case 'shape':
                    // Handle shape replay
                    break;
                case 'graph-function':
                    // Handle graph function replay
                    break;
            }
        }

        function updatePlaybackUI(playing) {
            if (playing) {
                playRecordingBtn.classList.add('hidden');
                pauseRecordingBtn.classList.remove('hidden');
                playbackProgressContainer.classList.remove('hidden');
            } else {
                playRecordingBtn.classList.remove('hidden');
                pauseRecordingBtn.classList.add('hidden');
                playbackProgressContainer.classList.add('hidden');
            }
        }

        function updateRecordingsList(recordings) {
            const recordingsList = document.getElementById('recordingsList');
            if (!recordingsList) {
                console.error('recordingsList element not found');
                return;
            }

            recordingsList.innerHTML = '<option value="">Select a recording...</option>';
            
            recordings.forEach(recording => {
                const option = document.createElement('option');
                option.value = recording.id;
                
                // Create a descriptive label
                const startTime = new Date(recording.startTime).toLocaleString();
                const duration = recording.duration ? ` (${Math.floor(recording.duration / 60)}:${(recording.duration % 60).toString().padStart(2, '0')})` : '';
                const subject = recording.subject ? ` - ${recording.subject}` : '';
                const teacher = recording.teacherUsername ? ` by ${recording.teacherUsername}` : '';
                
                option.textContent = `${startTime}${duration}${subject}${teacher}`;
                recordingsList.appendChild(option);
            });
            
            recordingsList.classList.remove('hidden');
        }

        // Add beforeunload handler to properly close connections
        window.addEventListener('beforeunload', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close(1000, 'Page unloading');
            }
        });

        // --- Event Listeners ---

        // Recording event listeners
        startRecordingBtn.addEventListener('click', startRecording);
        stopRecordingBtn.addEventListener('click', stopRecording);

        // Playback event listeners
        loadRecordingsBtn.addEventListener('click', loadRecordings);
        openPlaybackPageBtn.addEventListener('click', () => {
            const roomId = roomInput.value.trim();
            if (roomId) {
                window.open(`playback.html?room=${roomId}`, '_blank');
            } else {
                displayStatus('Please enter a room ID first', 'error');
            }
        });
        playRecordingBtn.addEventListener('click', () => {
            if (currentPlaybackRecording) {
                playRecording(currentPlaybackRecording);
            }
        });
        pauseRecordingBtn.addEventListener('click', pausePlayback);
        stopRecordingBtn.addEventListener('click', stopPlayback);

        // Handle recording selection change
        recordingsList.addEventListener('change', (e) => {
            const recordingId = e.target.value;
            if (recordingId) {
                // Clean up any existing media players
                cleanupMediaPlayers();
                
                // Load the selected recording
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({
                        type: 'load-recording',
                        recordingId: recordingId
                    }));
                }
            } else {
                // Clear current recording
                currentPlaybackRecording = null;
                playRecordingBtn.classList.add('hidden');
                pauseRecordingBtn.classList.add('hidden');
                stopRecordingBtn.classList.add('hidden');
                cleanupMediaPlayers();
            }
        });

        // Handle recording option changes
        recordVideo.addEventListener('change', () => {
            if (recordVideo.checked) {
                recordAudio.checked = true; // Video recording includes audio
                displayStatus('Video will be recorded as picture-in-picture overlay', 'info');
            }
        });

        recordAudio.addEventListener('change', () => {
            if (!recordAudio.checked && recordVideo.checked) {
                recordVideo.checked = false; // Can't have video without audio
            }
        });

        recordWhiteboard.addEventListener('change', () => {
            if (recordWhiteboard.checked) {
                displayStatus('Whiteboard will be recorded as background content', 'info');
            }
        });

        recordScreen.addEventListener('change', () => {
            if (recordScreen.checked) {
                displayStatus('Screen sharing will be recorded when active (replaces whiteboard)', 'info');
            }
        });

        // Debug recording setup
        const debugRecordingBtn = document.getElementById('debugRecordingBtn');
        if (debugRecordingBtn) {
            debugRecordingBtn.addEventListener('click', async () => {
                const status = checkVideoReadiness();
                let message = `Video Status: ${status.videoReady ? '✅ Ready' : '❌ Not Ready'}
                    Stream: ${status.hasLocalStream ? '✅ Active' : '❌ Missing'}
                    Video Element: ${status.hasLocalVideo ? '✅ Found' : '❌ Missing'}
                    Dimensions: ${status.videoWidth}x${status.videoHeight}
                    Tracks: ${status.videoTracks} video, ${status.audioTracks} audio
                    MediaRecorder: ${status.mediaRecorderSupported ? '✅ Supported' : '❌ Not Supported'}
                    WebM VP9: ${status.webmSupported ? '✅ Supported' : '❌ Not Supported'}`;
                
                // Test composite canvas creation
                if (status.videoReady) {
                    try {
                        const testCanvas = document.createElement('canvas');
                        testCanvas.width = 640;
                        testCanvas.height = 480;
                        const testCtx = testCanvas.getContext('2d');
                        testCtx.fillStyle = '#ff0000';
                        testCtx.fillRect(0, 0, 100, 100);
                        
                        const testStream = testCanvas.captureStream(30);
                        if (testStream && testStream.getVideoTracks().length > 0) {
                            message += '\nCanvas Capture: ✅ Working';
                        } else {
                            message += '\nCanvas Capture: ❌ Failed';
                        }
                    } catch (error) {
                        message += '\nCanvas Capture: ❌ Error - ' + error.message;
                    }
                }
                
                displayStatus(message, status.videoReady ? 'success' : 'error');
                console.log('Debug recording setup:', status);
            });
        }

        window.onload = () => {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            updateUIState();
            updateClassRosterUI([]);
            
            // Check for stored user info from homepage
            const storedUsername = localStorage.getItem('username');
            const storedRole = localStorage.getItem('userRole');
            
            if (storedUsername) {
                usernameInput.value = storedUsername;
                displayStatus(`Welcome ${storedRole}! Enter a room ID to create or join a class.`, 'info');
            }
        };

        async function uploadRecordingFile(blob, recordingType, recordingId, roomId) {
            try {
                console.log(`Starting upload for ${recordingType} recording, size: ${blob.size} bytes`);
                
                const formData = new FormData();
                formData.append('mediaFile', blob, `${recordingType}_recording.webm`);
                formData.append('recordingId', recordingId);
                formData.append('recordingType', recordingType);
                formData.append('roomId', roomId);

                console.log('Uploading to /upload-recording-media/ with data:', {
                    recordingType,
                    recordingId,
                    roomId,
                    blobSize: blob.size
                });

                const response = await fetch('/upload-recording-media/', {
                    method: 'POST',
                    body: formData
                });

                console.log('Upload response status:', response.status);

                if (response.ok) {
                    const result = await response.json();
                    console.log(`${recordingType} recording uploaded successfully:`, result);
                    displayStatus(`${recordingType} recording uploaded successfully`, 'success');
                } else {
                    const errorText = await response.text();
                    console.error('Upload failed with status:', response.status, 'response:', errorText);
                    throw new Error(`Upload failed: ${response.status} - ${errorText}`);
                }
            } catch (error) {
                console.error(`Error uploading ${recordingType} recording:`, error);
                displayStatus(`Failed to upload ${recordingType} recording: ${error.message}`, 'error');
            }
        }

        // --- Video Source Toggle Functions (for students) ---
        function showTeacherVideo() {
            if (myUserId === teacherId) return; // Only for students
            
            currentVideoSourcePreference = 'teacher';
            const teacherStream = remoteStreams[teacherId];
            if (localVideo && teacherStream) {
                localVideo.srcObject = teacherStream;
                const localVideoLabel = document.getElementById('localVideoLabel');
                if (localVideoLabel) {
                    const teacherName = (remoteUsernames && remoteUsernames[teacherId]) ? remoteUsernames[teacherId] : 'Teacher';
                    localVideoLabel.textContent = teacherName;
                }
                if (currentVideoSource) {
                    currentVideoSource.textContent = teacherName;
                }
            }
        }

        function showScreenShareVideo() {
            if (myUserId === teacherId) return; // Only for students
            if (!screenShareOwnerId) return; // No one is screen sharing
            
            currentVideoSourcePreference = 'screenShare';
            const screenShareStream = remoteStreams[screenShareOwnerId];
            if (localVideo && screenShareStream) {
                localVideo.srcObject = screenShareStream;
                const localVideoLabel = document.getElementById('localVideoLabel');
                if (localVideoLabel) {
                    const sharerName = (remoteUsernames && remoteUsernames[screenShareOwnerId]) ? remoteUsernames[screenShareOwnerId] : 'Screen Sharer';
                    localVideoLabel.textContent = sharerName + ' (Screen Sharing)';
                }
                if (currentVideoSource) {
                    const sharerName = (remoteUsernames && remoteUsernames[screenShareOwnerId]) ? remoteUsernames[screenShareOwnerId] : 'Screen Share';
                    currentVideoSource.textContent = sharerName;
                }
            }
        }

        function updateVideoSourceToggleVisibility() {
            if (myUserId === teacherId) {
                // Teachers don't need this toggle
                if (videoSourceToggle) videoSourceToggle.classList.add('hidden');
                return;
            }
            
            // Show toggle for students when both teacher and screen share are available
            if (screenShareOwnerId && remoteStreams[teacherId] && remoteStreams[screenShareOwnerId]) {
                if (videoSourceToggle) videoSourceToggle.classList.remove('hidden');
            } else {
                if (videoSourceToggle) videoSourceToggle.classList.add('hidden');
            }
        }

        // --- Utility Functions ---
    </script>
</body>
</html>
